(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_a276545f._.js", {

"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray;
    new ("function" === typeof WeakMap ? WeakMap : Map)();
    var createTask = console.createTask ? console.createTask : function() {
        return null;
    }, specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, Error("react-stack-top-frame"), createTask(getTaskName(type)));
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/@mapbox/search-js-core/dist/index-esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AddressAutofillCore": (()=>AddressAutofillCore),
    "Evented": (()=>Evented),
    "GeocodingCore": (()=>GeocodingCore),
    "LngLat": (()=>LngLat),
    "LngLatBounds": (()=>LngLatBounds),
    "MapboxAutofill": (()=>AddressAutofillCore),
    "MapboxError": (()=>MapboxError),
    "MapboxGeocode": (()=>GeocodingCore),
    "MapboxValidate": (()=>ValidationCore),
    "MatchCodeConfidence": (()=>MatchCodeConfidence),
    "MatchCodeType": (()=>MatchCodeType),
    "SearchBoxCore": (()=>SearchBoxCore),
    "SearchSession": (()=>SearchSession),
    "SessionToken": (()=>SessionToken),
    "ValidationCore": (()=>ValidationCore),
    "debounce": (()=>debounce),
    "featureToSuggestion": (()=>featureToSuggestion),
    "polyfillFetch": (()=>polyfillFetch)
});
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value1)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value1
    }) : obj[key] = value1;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude)=>{
    var target = {};
    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
var __accessCheck = (obj, member, msg)=>{
    if (!member.has(obj)) throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter)=>{
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value1)=>{
    if (member.has(obj)) throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value1);
};
var __privateSet = (obj, member, value1, setter)=>{
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value1) : member.set(obj, value1);
    return value1;
};
var __privateWrapper = (obj, member, setter, getter)=>{
    return {
        set _ (value){
            __privateSet(obj, member, value, setter);
        },
        get _ () {
            return __privateGet(obj, member, getter);
        }
    };
};
var __privateMethod = (obj, member, method)=>{
    __accessCheck(obj, member, "access private method");
    return method;
};
var __async = (__this, __arguments, generator)=>{
    return new Promise((resolve, reject)=>{
        var fulfilled = (value1)=>{
            try {
                step(generator.next(value1));
            } catch (e) {
                reject(e);
            }
        };
        var rejected = (value1)=>{
            try {
                step(generator.throw(value1));
            } catch (e) {
                reject(e);
            }
        };
        var step = (x)=>x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
    });
};
// src/autofill/constants.ts
var SEARCH_URL = `https://api.mapbox.com/autofill/v1`;
var ENDPOINT_SUGGEST = "suggest";
var ENDPOINT_RETRIEVE = "retrieve";
var SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;
var RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;
// src/LngLat.ts
var LngLat = class {
    constructor(lng, lat){
        if (isNaN(lng) || isNaN(lat)) {
            throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);
        }
        this.lng = +lng;
        this.lat = +lat;
        if (this.lat > 90 || this.lat < -90) {
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        if (this.lng > 180 || this.lng < -180) {
            throw new Error("Invalid LngLat longitude value: must be between -180 and 180");
        }
    }
    toArray() {
        return [
            this.lng,
            this.lat
        ];
    }
    toString() {
        return `LngLat(${this.lng}, ${this.lat})`;
    }
    static convert(input) {
        if (input instanceof LngLat) {
            return new LngLat(input.lng, input.lat);
        }
        if (Array.isArray(input) && input.length === 2) {
            return new LngLat(Number(input[0]), Number(input[1]));
        }
        if (!Array.isArray(input) && typeof input == "object" && input !== null && ("lng" in input || "lon" in input) && "lat" in input) {
            return new LngLat(Number("lng" in input ? input.lng : input.lon), Number(input.lat));
        }
        throw new Error("`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
    }
};
// src/LngLatBounds.ts
var LngLatBounds = class {
    constructor(sw, ne){
        this._sw = LngLat.convert(sw);
        this._ne = LngLat.convert(ne);
    }
    getSouthWest() {
        return this._sw;
    }
    getNorthEast() {
        return this._ne;
    }
    getNorthWest() {
        return new LngLat(this.getWest(), this.getNorth());
    }
    getSouthEast() {
        return new LngLat(this.getEast(), this.getSouth());
    }
    getWest() {
        return this._sw.lng;
    }
    getSouth() {
        return this._sw.lat;
    }
    getEast() {
        return this._ne.lng;
    }
    getNorth() {
        return this._ne.lat;
    }
    toArray() {
        return [
            this._sw.toArray(),
            this._ne.toArray()
        ];
    }
    toFlatArray() {
        return [
            this._sw.lng,
            this._sw.lat,
            this._ne.lng,
            this._ne.lat
        ];
    }
    toString() {
        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
    }
    static convert(input) {
        if (!input) {
            throw new Error("Invalid LngLatBounds convert value: falsy");
        }
        if (input instanceof LngLatBounds) {
            return new LngLatBounds(input.getSouthWest(), input.getNorthEast());
        }
        if (Array.isArray(input) && input.length === 2) {
            return new LngLatBounds(LngLat.convert(input[0]), LngLat.convert(input[1]));
        }
        if (Array.isArray(input) && input.length === 4) {
            return new LngLatBounds(LngLat.convert([
                input[0],
                input[1]
            ]), LngLat.convert([
                input[2],
                input[3]
            ]));
        }
        throw new Error("`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]");
    }
};
// src/utils/uuid.ts
function generateUUID() {
    const randomString = Math.random().toString(16) + Date.now().toString(16) + Math.random().toString(16);
    const uuidString = randomString.replace(/\./g, "");
    const uuid = [
        uuidString.slice(0, 8),
        uuidString.slice(8, 12),
        "4" + uuidString.slice(12, 15) + "-8" + uuidString.slice(15, 18),
        uuidString.slice(18, 30)
    ].join("-");
    return uuid;
}
// src/SessionToken.ts
var SessionToken = class {
    constructor(id){
        this.id = id != null ? id : generateUUID();
    }
    toString() {
        return this.id;
    }
    static convert(token) {
        return new SessionToken(token instanceof SessionToken ? token.id : token.toString());
    }
};
// src/MapboxError.ts
var UNKNOWN_ERROR = "Unknown error";
var MapboxError = class extends Error {
    constructor(json, statusCode){
        super(String(json.message || json.error || UNKNOWN_ERROR));
        this.name = "MapboxError";
        this.statusCode = statusCode;
    }
    toString() {
        return `${this.name} (${this.statusCode}): ${this.message}`;
    }
};
function handleNonOkRes(res) {
    return __async(this, null, function*() {
        if (!res.ok) {
            const json = yield res.json();
            throw new MapboxError(json, res.status);
        }
    });
}
// src/fetch.ts
var _fetchImpl = globalThis.fetch;
var _abortControllerImpl = globalThis.AbortController;
function polyfillFetch({ fetch, AbortController }, force = false) {
    if (!fetch) {
        throw new Error("Fetch implementation must include implementations of `fetch`.");
    }
    if (_fetchImpl && !force) {
        return;
    }
    _fetchImpl = fetch;
    _abortControllerImpl = AbortController;
}
function getFetch() {
    if (!_fetchImpl) {
        throw new Error("Fetch implementation not found. Please include a fetch polyfill in your application or use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.");
    }
    return {
        fetch: _fetchImpl,
        AbortController: _abortControllerImpl
    };
}
// src/utils/queryParams.ts
function queryParams(...objects) {
    const params = [];
    for (const obj of objects){
        if (!obj) continue;
        const entries = Object.entries(obj);
        for (const [key, value1] of entries){
            if (value1 == null) continue;
            params.push(`${key}=${encodeURIComponent(String(value1))}`);
        }
    }
    return params.join("&");
}
// src/autofill/AddressAutofillCore.ts
var _responseHeaders, _getQueryParams, getQueryParams_fn;
var _AddressAutofillCore = class {
    constructor(options = {}){
        __privateAdd(this, _getQueryParams);
        __privateAdd(this, _responseHeaders, void 0);
        const _a = options, { accessToken } = _a, defaults = __objRest(_a, [
            "accessToken"
        ]);
        this.accessToken = accessToken;
        this.defaults = __spreadValues(__spreadValues({}, _AddressAutofillCore.defaults), defaults);
    }
    get responseHeaders() {
        return __privateGet(this, _responseHeaders);
    }
    suggest(searchText, optionsArg) {
        return __async(this, null, function*() {
            if (!searchText) {
                throw new Error("searchText is required");
            }
            const { sessionToken, signal } = optionsArg;
            const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {
                sessionToken
            });
            const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);
            url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);
            const { fetch } = getFetch();
            const res = yield fetch(url.toString(), {
                signal
            });
            __privateSet(this, _responseHeaders, res.headers);
            yield handleNonOkRes(res);
            const json = yield res.json();
            return __spreadProps(__spreadValues({}, json), {
                suggestions: json.suggestions.map((suggestion)=>{
                    return __spreadProps(__spreadValues({}, suggestion), {
                        original_search_text: searchText
                    });
                }),
                url: url.toString()
            });
        });
    }
    retrieve(suggestion, optionsArg) {
        return __async(this, null, function*() {
            if (!suggestion) {
                throw new Error("suggestion is required");
            }
            if (!this.canRetrieve(suggestion)) {
                throw new Error("suggestion cannot be retrieved");
            }
            const { sessionToken: sessionTokenLike, signal } = optionsArg;
            const sessionToken = SessionToken.convert(sessionTokenLike);
            const url = new URL(`${RETRIEVE_URL}/${suggestion.action.id}`);
            url.search = queryParams({
                access_token: this.accessToken,
                session_token: sessionToken.id
            });
            const { fetch } = getFetch();
            const res = yield fetch(url.toString(), {
                signal
            });
            yield handleNonOkRes(res);
            const json = yield res.json();
            json.url = url.toString();
            return json;
        });
    }
    canRetrieve(suggestion) {
        const action = suggestion.action;
        return typeof (action == null ? void 0 : action.id) === "string";
    }
};
var AddressAutofillCore = _AddressAutofillCore;
_responseHeaders = new WeakMap();
_getQueryParams = new WeakSet();
getQueryParams_fn = function(options) {
    return queryParams({
        types: "address",
        access_token: this.accessToken,
        streets: options.streets,
        language: options.language,
        country: options.country,
        limit: options.limit
    }, options.sessionToken && {
        session_token: SessionToken.convert(options.sessionToken).id
    }, options.proximity && {
        proximity: typeof options.proximity === "string" ? options.proximity : LngLat.convert(options.proximity).toArray().join(",")
    }, options.bbox && {
        bbox: typeof options.bbox === "string" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(",")
    });
};
AddressAutofillCore.defaults = {
    language: "en",
    proximity: "ip",
    streets: true
};
// src/searchbox/constants.ts
var SEARCH_URL2 = `https://api.mapbox.com/search/searchbox/v1`;
var ENDPOINT_SUGGEST2 = "suggest";
var ENDPOINT_RETRIEVE2 = "retrieve";
var ENDPOINT_CATEGORY = "category";
var ENDPOINT_REVERSE = "reverse";
var SUGGEST_URL2 = `${SEARCH_URL2}/${ENDPOINT_SUGGEST2}`;
var RETRIEVE_URL2 = `${SEARCH_URL2}/${ENDPOINT_RETRIEVE2}`;
var CATEGORY_URL = `${SEARCH_URL2}/${ENDPOINT_CATEGORY}`;
var REVERSE_URL = `${SEARCH_URL2}/${ENDPOINT_REVERSE}`;
// src/searchbox/SearchBoxCore.ts
var _getQueryParams2, getQueryParams_fn2;
var _SearchBoxCore = class {
    constructor(options = {}){
        __privateAdd(this, _getQueryParams2);
        const _a = options, { accessToken } = _a, defaults = __objRest(_a, [
            "accessToken"
        ]);
        this.accessToken = accessToken;
        this.defaults = __spreadValues(__spreadValues({}, _SearchBoxCore.defaults), defaults);
    }
    suggest(searchText, optionsArg) {
        return __async(this, null, function*() {
            if (!searchText) {
                throw new Error("searchText is required");
            }
            const { sessionToken, signal } = optionsArg;
            const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {
                q: searchText,
                sessionToken
            });
            if (options.eta_type && (!options.origin || !options.navigation_profile)) {
                throw new Error("to provide eta estimate: eta, navigation_profile, and origin are required");
            }
            if (options.origin && !options.navigation_profile) {
                throw new Error("to provide distance estimate: both navigation_profile and origin are required");
            }
            const url = new URL(SUGGEST_URL2);
            url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);
            const { fetch } = getFetch();
            const res = yield fetch(url.toString(), {
                signal
            });
            yield handleNonOkRes(res);
            const json = yield res.json();
            json.url = url.toString();
            return json;
        });
    }
    retrieve(suggestion, optionsArg) {
        return __async(this, null, function*() {
            if (!suggestion) {
                throw new Error("suggestion is required");
            }
            const { sessionToken: sessionTokenLike, signal, language } = optionsArg;
            const sessionToken = SessionToken.convert(sessionTokenLike);
            const options = __spreadValues(__spreadValues({}, this.defaults), language && {
                language
            });
            const url = new URL(`${RETRIEVE_URL2}/${encodeURIComponent(suggestion.mapbox_id)}`);
            url.search = queryParams({
                access_token: this.accessToken,
                session_token: sessionToken.id
            }, {
                language: options.language
            });
            const { fetch } = getFetch();
            const res = yield fetch(url.toString(), {
                signal
            });
            yield handleNonOkRes(res);
            const json = yield res.json();
            json.url = url.toString();
            return json;
        });
    }
    category(_0) {
        return __async(this, arguments, function*(category, optionsArg = {}) {
            if (!category) {
                throw new Error("category is required");
            }
            const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);
            const url = new URL(`${CATEGORY_URL}/${encodeURIComponent(category)}`);
            url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);
            const { fetch } = getFetch();
            const res = yield fetch(url.toString(), {
                signal: options.signal
            });
            yield handleNonOkRes(res);
            const json = yield res.json();
            json.url = url.toString();
            return json;
        });
    }
    reverse(_0) {
        return __async(this, arguments, function*(lngLat, optionsArg = {}) {
            if (!lngLat) {
                throw new Error("lngLat is required");
            }
            const [lng, lat] = typeof lngLat === "string" ? lngLat.split(",").map((x)=>parseFloat(x)) : LngLat.convert(lngLat).toArray();
            if (isNaN(lng) || isNaN(lat)) {
                throw new Error("lngLat is required");
            }
            const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);
            const url = new URL(REVERSE_URL);
            url.search = queryParams({
                access_token: this.accessToken,
                language: options.language,
                limit: options.limit,
                longitude: lng,
                latitude: lat
            }, options.types && {
                types: typeof options.types === "string" ? options.types : [
                    ...options.types
                ].join(",")
            });
            const { fetch } = getFetch();
            const res = yield fetch(url.toString(), {
                signal: options.signal
            });
            yield handleNonOkRes(res);
            const json = yield res.json();
            json.url = url.toString();
            return json;
        });
    }
};
var SearchBoxCore = _SearchBoxCore;
_getQueryParams2 = new WeakSet();
getQueryParams_fn2 = function(options) {
    return queryParams({
        q: options.q,
        access_token: this.accessToken,
        language: options.language,
        limit: options.limit,
        navigation_profile: options.navigation_profile,
        route: options.route,
        route_geometry: options.route_geometry,
        sar_type: options.sar_type,
        time_deviation: options.time_deviation,
        eta_type: options.eta_type,
        country: options.country,
        poi_category: options.poi_category,
        rich_metadata_provider: options.rich_metadata_provider,
        poi_category_exclusions: options.poi_category_exclusions
    }, options.sessionToken && {
        session_token: SessionToken.convert(options.sessionToken).id
    }, options.proximity && {
        proximity: typeof options.proximity === "string" ? options.proximity : LngLat.convert(options.proximity).toArray().join(",")
    }, options.origin && {
        origin: typeof options.origin === "string" ? options.origin : LngLat.convert(options.origin).toArray().join(",")
    }, options.bbox && {
        bbox: typeof options.bbox === "string" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(",")
    }, options.types && {
        types: typeof options.types === "string" ? options.types : [
            ...options.types
        ].join(",")
    });
};
SearchBoxCore.defaults = {
    language: "en"
};
// src/validate/constants.ts
var SEARCH_URL3 = `https://api.mapbox.com/autofill/v1`;
var ENDPOINT_VALIDATE = "retrieve";
var VALIDATE_URL = `${SEARCH_URL3}/${ENDPOINT_VALIDATE}`;
// src/validate/ValidationCore.ts
var _getQueryParams3, getQueryParams_fn3;
var _ValidationCore = class {
    constructor(options = {}){
        __privateAdd(this, _getQueryParams3);
        const _a = options, { accessToken } = _a, defaults = __objRest(_a, [
            "accessToken"
        ]);
        this.accessToken = accessToken;
        this.defaults = __spreadValues(__spreadValues({}, _ValidationCore.defaults), defaults);
    }
    validate(searchText, optionsArg) {
        return __async(this, null, function*() {
            if (!searchText) {
                throw new Error("searchText is required");
            }
            const { sessionToken, signal } = optionsArg;
            const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {
                sessionToken
            });
            const url = new URL(`${VALIDATE_URL}/${encodeURIComponent(searchText)}`);
            url.search = __privateMethod(this, _getQueryParams3, getQueryParams_fn3).call(this, options);
            const { fetch } = getFetch();
            const res = yield fetch(url.toString(), {
                signal
            });
            yield handleNonOkRes(res);
            const json = yield res.json();
            json.url = url.toString();
            if (json.features.length > 0) {
                json.features = [
                    json.features[0]
                ];
            }
            return json;
        });
    }
};
var ValidationCore = _ValidationCore;
_getQueryParams3 = new WeakSet();
getQueryParams_fn3 = function(options) {
    return queryParams({
        access_token: this.accessToken,
        language: options.language,
        country: options.country
    }, options.sessionToken && {
        session_token: SessionToken.convert(options.sessionToken).id
    }, options.proximity && {
        proximity: typeof options.proximity === "string" ? options.proximity : LngLat.convert(options.proximity).toArray().join(",")
    }, options.bbox && {
        bbox: typeof options.bbox === "string" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(",")
    });
};
ValidationCore.defaults = {
    language: "en",
    proximity: "ip"
};
// src/geocode/constants.ts
var BASE_URL = `https://api.mapbox.com/search/geocode/v6`;
var FORWARD_URL = `${BASE_URL}/forward`;
var REVERSE_URL2 = `${BASE_URL}/reverse`;
var BATCH_URL = `${BASE_URL}/batch`;
// src/geocode/GeocodingCore.ts
var REVERSE_GEOCODE_COORD_REGEX = /^[ ]*(-?\d{1,3}(\.\d{0,256})?)[, ]+(-?\d{1,3}(\.\d{0,256})?)[ ]*$/;
var SPACES_OR_COMMA_REGEX = /[\s,]+/;
var _responseHeaders2, _getQueryParams4, getQueryParams_fn4;
var GeocodingCore = class {
    constructor(options = {}){
        __privateAdd(this, _getQueryParams4);
        __privateAdd(this, _responseHeaders2, void 0);
        const _a = options, { accessToken } = _a, defaults = __objRest(_a, [
            "accessToken"
        ]);
        this.accessToken = accessToken;
        this.defaults = __spreadValues({}, defaults);
    }
    get responseHeaders() {
        return __privateGet(this, _responseHeaders2);
    }
    forward(searchText, optionsArg) {
        return __async(this, null, function*() {
            if (!searchText) {
                throw new Error("searchText is required");
            }
            let signal;
            if (optionsArg) {
                ({ signal } = optionsArg);
            }
            const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {
                q: searchText
            });
            const url = new URL(`${FORWARD_URL}`);
            url.search = __privateMethod(this, _getQueryParams4, getQueryParams_fn4).call(this, options);
            const { fetch } = getFetch();
            const fetchInit = signal ? {
                signal
            } : {};
            const res = yield fetch(url.toString(), fetchInit);
            __privateSet(this, _responseHeaders2, res.headers);
            yield handleNonOkRes(res);
            const json = yield res.json();
            json.url = url.toString();
            return json;
        });
    }
    reverse(lngLat, optionsArg) {
        return __async(this, null, function*() {
            if (!lngLat) {
                throw new Error("lngLat is required");
            }
            let signal;
            if (optionsArg) {
                ({ signal } = optionsArg);
            }
            let lngLatObj;
            if (typeof lngLat === "string") {
                const [lng, lat] = lngLat.split(",");
                lngLatObj = new LngLat(Number(lng), Number(lat));
            } else {
                lngLatObj = LngLat.convert(lngLat);
            }
            const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {
                longitude: lngLatObj.lng,
                latitude: lngLatObj.lat
            });
            const url = new URL(`${REVERSE_URL2}`);
            url.search = __privateMethod(this, _getQueryParams4, getQueryParams_fn4).call(this, options, true);
            const { fetch } = getFetch();
            const fetchInit = signal ? {
                signal
            } : {};
            const res = yield fetch(url.toString(), fetchInit);
            __privateSet(this, _responseHeaders2, res.headers);
            yield handleNonOkRes(res);
            const json = yield res.json();
            json.url = url.toString();
            return json;
        });
    }
    suggest(searchText, optionsArg) {
        return __async(this, null, function*() {
            const isReverseQuery = REVERSE_GEOCODE_COORD_REGEX.test(searchText);
            if (isReverseQuery) {
                const coordinates = searchText.trim().split(SPACES_OR_COMMA_REGEX).map((part)=>part.trim()).join(",");
                return this.reverse(coordinates, optionsArg);
            } else {
                return this.forward(searchText, optionsArg);
            }
        });
    }
    retrieve(suggestion) {
        return __async(this, null, function*() {
            return suggestion;
        });
    }
};
_responseHeaders2 = new WeakMap();
_getQueryParams4 = new WeakSet();
getQueryParams_fn4 = function(options, isReverse = false) {
    if (isReverse) {
        [
            "proximity",
            "autocomplete",
            "bbox"
        ].forEach((key)=>{
            if (key in options) {
                delete options[key];
            }
        });
    }
    return queryParams({
        q: options.q,
        longitude: options.longitude,
        latitude: options.latitude,
        access_token: this.accessToken,
        permanent: options.permanent,
        language: options.language,
        country: options.country,
        limit: options.limit,
        autocomplete: options.autocomplete,
        worldview: options.worldview
    }, options.sessionToken && {
        session_token: SessionToken.convert(options.sessionToken).id
    }, options.proximity && {
        proximity: typeof options.proximity === "string" ? options.proximity : LngLat.convert(options.proximity).toArray().join(",")
    }, options.bbox && {
        bbox: typeof options.bbox === "string" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(",")
    }, options.types && {
        types: typeof options.types === "string" ? options.types : [
            ...options.types
        ].join(",")
    });
};
// src/types.ts
var MatchCodeType = /* @__PURE__ */ ((MatchCodeType2)=>{
    MatchCodeType2["matched"] = "matched";
    MatchCodeType2["unmatched"] = "unmatched";
    MatchCodeType2["plausible"] = "plausible";
    MatchCodeType2["not_applicable"] = "not_applicable";
    MatchCodeType2["inferred"] = "inferred";
    return MatchCodeType2;
})(MatchCodeType || {});
var MatchCodeConfidence = /* @__PURE__ */ ((MatchCodeConfidence2)=>{
    MatchCodeConfidence2["exact"] = "exact";
    MatchCodeConfidence2["high"] = "high";
    MatchCodeConfidence2["medium"] = "medium";
    MatchCodeConfidence2["low"] = "low";
    return MatchCodeConfidence2;
})(MatchCodeConfidence || {});
// src/utils/Evented.ts
var _listeners;
var Evented = class {
    constructor(){
        __privateAdd(this, _listeners, {});
    }
    addEventListener(type, listener) {
        const listenersArr = __privateGet(this, _listeners);
        if (!listenersArr[type]) {
            listenersArr[type] = [];
        }
        listenersArr[type].push(listener);
    }
    removeEventListener(type, listener) {
        const listenersArr = __privateGet(this, _listeners);
        if (!listenersArr[type]) {
            return;
        }
        const listeners = listenersArr[type];
        const index = listeners.indexOf(listener);
        if (index !== -1) {
            listeners.splice(index, 1);
        }
    }
    fire(type, arg0) {
        const listenersArr = __privateGet(this, _listeners);
        if (!listenersArr[type]) {
            return;
        }
        const listeners = listenersArr[type];
        for (const listener of listeners){
            listener(arg0);
        }
    }
};
_listeners = new WeakMap();
// src/utils/debounce.ts
function debounce(func, wait, signalFn) {
    let timeout = null;
    return (...args)=>{
        if (timeout !== null) {
            clearTimeout(timeout);
        }
        const signal = signalFn && signalFn();
        timeout = setTimeout(()=>{
            timeout = null;
            if (signal == null ? void 0 : signal.aborted) {
                return;
            }
            func(...args);
        }, wait);
    };
}
// src/SearchSession.ts
function createAbortController() {
    const { AbortController } = getFetch();
    return new AbortController();
}
var _sessionTokenBase, _sessionIncrementer, _sessionTokenCustom, _suggestions, _abort, _suggestDebounce;
var SearchSession = class extends Evented {
    constructor(search, wait = 0){
        super();
        __privateAdd(this, _sessionTokenBase, new SessionToken());
        __privateAdd(this, _sessionIncrementer, 0);
        __privateAdd(this, _sessionTokenCustom, false);
        __privateAdd(this, _suggestions, void 0);
        __privateAdd(this, _abort, createAbortController());
        __privateAdd(this, _suggestDebounce, void 0);
        __privateSet(this, _suggestDebounce, debounce((_0, ..._1)=>__async(this, [
                _0,
                ..._1
            ], function*(searchText, options = {}) {
                __privateGet(this, _abort).abort();
                __privateSet(this, _abort, createAbortController());
                if (!searchText) {
                    __privateSet(this, _suggestions, null);
                    this.fire("suggest", __privateGet(this, _suggestions));
                    return;
                }
                try {
                    const res = yield this.search.suggest(searchText, __spreadProps(__spreadValues({
                        sessionToken: this.sessionToken
                    }, options), {
                        signal: __privateGet(this, _abort).signal
                    }));
                    __privateSet(this, _suggestions, res);
                    this.fire("suggest", res);
                } catch (err) {
                    if (err.name === "AbortError") {
                        return;
                    }
                    this.fire("suggesterror", err);
                }
            }), wait, ()=>__privateGet(this, _abort).signal));
        Object.defineProperties(this, {
            search: {
                value: search,
                writable: false
            },
            debounce: {
                value: wait,
                writable: false
            }
        });
    }
    get sessionToken() {
        if (__privateGet(this, _sessionTokenCustom)) {
            return __privateGet(this, _sessionTokenBase).id;
        }
        return `${__privateGet(this, _sessionTokenBase).id}.${__privateGet(this, _sessionIncrementer)}`;
    }
    set sessionToken(token) {
        __privateSet(this, _sessionTokenCustom, true);
        __privateSet(this, _sessionTokenBase, new SessionToken(token));
    }
    get suggestions() {
        return __privateGet(this, _suggestions);
    }
    suggest(searchText, options) {
        __privateGet(this, _suggestDebounce).call(this, searchText, options);
        return new Promise((resolve, reject)=>{
            let suggestFn;
            let suggestErrorFn;
            suggestFn = (res)=>{
                this.removeEventListener("suggest", suggestFn);
                this.removeEventListener("suggesterror", suggestErrorFn);
                resolve(res);
            };
            suggestErrorFn = (err)=>{
                this.removeEventListener("suggest", suggestFn);
                this.removeEventListener("suggesterror", suggestErrorFn);
                reject(err);
            };
            this.addEventListener("suggest", suggestFn);
            this.addEventListener("suggesterror", suggestErrorFn);
        });
    }
    clear() {
        this.suggest("");
    }
    retrieve(suggestion, options) {
        return __async(this, null, function*() {
            const res = yield this.search.retrieve(suggestion, __spreadValues({
                sessionToken: this.sessionToken
            }, options));
            this.fire("retrieve", res);
            return res;
        });
    }
    canRetrieve(suggestion) {
        if (!this.search.canRetrieve) {
            return true;
        }
        return this.search.canRetrieve(suggestion);
    }
    canSuggest(suggestion) {
        if (!this.search.canSuggest) {
            return true;
        }
        return this.search.canSuggest(suggestion);
    }
    abort() {
        __privateGet(this, _abort).abort();
        __privateSet(this, _abort, createAbortController());
    }
    incrementSession() {
        __privateWrapper(this, _sessionIncrementer)._++;
    }
};
_sessionTokenBase = new WeakMap();
_sessionIncrementer = new WeakMap();
_sessionTokenCustom = new WeakMap();
_suggestions = new WeakMap();
_abort = new WeakMap();
_suggestDebounce = new WeakMap();
// src/featureToSuggestion.ts
function featureToSuggestion(feature) {
    const { properties } = feature;
    return __spreadValues({}, properties);
}
;
 //# sourceMappingURL=index-esm.js.map
}}),
"[project]/node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "arrow": (()=>arrow),
    "autoPlacement": (()=>autoPlacement),
    "computePosition": (()=>computePosition),
    "detectOverflow": (()=>detectOverflow),
    "flip": (()=>flip),
    "hide": (()=>hide),
    "inline": (()=>inline),
    "limitShift": (()=>limitShift),
    "offset": (()=>offset),
    "rectToClientRect": (()=>rectToClientRect),
    "shift": (()=>shift),
    "size": (()=>size)
});
function getSide(placement) {
    return placement.split('-')[0];
}
function getAlignment(placement) {
    return placement.split('-')[1];
}
function getMainAxisFromPlacement(placement) {
    return [
        'top',
        'bottom'
    ].includes(getSide(placement)) ? 'x' : 'y';
}
function getLengthFromAxis(axis) {
    return axis === 'y' ? 'height' : 'width';
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
    let { reference, floating } = _ref;
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const mainAxis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(mainAxis);
    const commonAlign = reference[length] / 2 - floating[length] / 2;
    const side = getSide(placement);
    const isVertical = mainAxis === 'x';
    let coords;
    switch(side){
        case 'top':
            coords = {
                x: commonX,
                y: reference.y - floating.height
            };
            break;
        case 'bottom':
            coords = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;
        case 'right':
            coords = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;
        case 'left':
            coords = {
                x: reference.x - floating.width,
                y: commonY
            };
            break;
        default:
            coords = {
                x: reference.x,
                y: reference.y
            };
    }
    switch(getAlignment(placement)){
        case 'start':
            coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
            break;
        case 'end':
            coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
            break;
    }
    return coords;
}
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */ const computePosition = async (reference, floating, config)=>{
    const { placement = 'bottom', strategy = 'absolute', middleware = [], platform } = config;
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
    {
        if (platform == null) {
            console.error([
                'Floating UI: `platform` property was not passed to config. If you',
                'want to use Floating UI on the web, install @floating-ui/dom',
                'instead of the /core package. Otherwise, you can create your own',
                '`platform`: https://floating-ui.com/docs/platform'
            ].join(' '));
        }
        if (middleware.filter((_ref)=>{
            let { name } = _ref;
            return name === 'autoPlacement' || name === 'flip';
        }).length > 1) {
            throw new Error([
                'Floating UI: duplicate `flip` and/or `autoPlacement`',
                'middleware detected. This will lead to an infinite loop. Ensure only',
                'one of either has been passed to the `middleware` array.'
            ].join(' '));
        }
    }
    let rects = await platform.getElementRects({
        reference,
        floating,
        strategy
    });
    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for(let i = 0; i < middleware.length; i++){
        const { name, fn } = middleware[i];
        const { x: nextX, y: nextY, data, reset } = await fn({
            x,
            y,
            initialPlacement: placement,
            placement: statefulPlacement,
            strategy,
            middlewareData,
            rects,
            platform,
            elements: {
                reference,
                floating
            }
        });
        x = nextX != null ? nextX : x;
        y = nextY != null ? nextY : y;
        middlewareData = {
            ...middlewareData,
            [name]: {
                ...middlewareData[name],
                ...data
            }
        };
        {
            if (resetCount > 50) {
                console.warn([
                    'Floating UI: The middleware lifecycle appears to be running in an',
                    'infinite loop. This is usually caused by a `reset` continually',
                    'being returned without a break condition.'
                ].join(' '));
            }
        }
        if (reset && resetCount <= 50) {
            resetCount++;
            if (typeof reset === 'object') {
                if (reset.placement) {
                    statefulPlacement = reset.placement;
                }
                if (reset.rects) {
                    rects = reset.rects === true ? await platform.getElementRects({
                        reference,
                        floating,
                        strategy
                    }) : reset.rects;
                }
                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
            }
            i = -1;
            continue;
        }
    }
    return {
        x,
        y,
        placement: statefulPlacement,
        strategy,
        middlewareData
    };
};
function expandPaddingObject(padding) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...padding
    };
}
function getSideObjectFromPadding(padding) {
    return typeof padding !== 'number' ? expandPaddingObject(padding) : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding
    };
}
function rectToClientRect(rect) {
    return {
        ...rect,
        top: rect.y,
        left: rect.x,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
    };
}
/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */ async function detectOverflow(middlewareArguments, options) {
    var _await$platform$isEle;
    if (options === void 0) {
        options = {};
    }
    const { x, y, platform, rects, elements, strategy } = middlewareArguments;
    const { boundary = 'clippingAncestors', rootBoundary = 'viewport', elementContext = 'floating', altBoundary = false, padding = 0 } = options;
    const paddingObject = getSideObjectFromPadding(padding);
    const altContext = elementContext === 'floating' ? 'reference' : 'floating';
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform.getClippingRect({
        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),
        boundary,
        rootBoundary,
        strategy
    }));
    const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: elementContext === 'floating' ? {
            ...rects.floating,
            x,
            y
        } : rects.reference,
        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),
        strategy
    }) : rects[elementContext]);
    return {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
}
const min = Math.min;
const max = Math.max;
function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
}
/**
 * Positions an inner element of the floating element such that it is centered
 * to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */ const arrow = (options)=>({
        name: 'arrow',
        options,
        async fn (middlewareArguments) {
            // Since `element` is required, we don't Partial<> the type
            const { element, padding = 0 } = options != null ? options : {};
            const { x, y, placement, rects, platform } = middlewareArguments;
            if (element == null) {
                {
                    console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');
                }
                return {};
            }
            const paddingObject = getSideObjectFromPadding(padding);
            const coords = {
                x,
                y
            };
            const axis = getMainAxisFromPlacement(placement);
            const alignment = getAlignment(placement);
            const length = getLengthFromAxis(axis);
            const arrowDimensions = await platform.getDimensions(element);
            const minProp = axis === 'y' ? 'top' : 'left';
            const maxProp = axis === 'y' ? 'bottom' : 'right';
            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
            const startDiff = coords[axis] - rects.reference[axis];
            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
            let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
            if (clientSize === 0) {
                clientSize = rects.floating[length];
            }
            const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center
            // point is outside the floating element's bounds
            const min = paddingObject[minProp];
            const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];
            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
            const offset = within(min, center, max); // Make sure that arrow points at the reference
            const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];
            const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];
            const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;
            return {
                [axis]: coords[axis] - alignmentOffset,
                data: {
                    [axis]: offset,
                    centerOffset: center - offset
                }
            };
        }
    });
const hash$1 = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
};
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (matched)=>hash$1[matched]);
}
function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
        rtl = false;
    }
    const alignment = getAlignment(placement);
    const mainAxis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(mainAxis);
    let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
    if (rects.reference[length] > rects.floating[length]) {
        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return {
        main: mainAlignmentSide,
        cross: getOppositePlacement(mainAlignmentSide)
    };
}
const hash = {
    start: 'end',
    end: 'start'
};
function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (matched)=>hash[matched]);
}
const sides = [
    'top',
    'right',
    'bottom',
    'left'
];
const allPlacements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + "-start", side + "-end"), []);
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
    const allowedPlacementsSortedByAlignment = alignment ? [
        ...allowedPlacements.filter((placement)=>getAlignment(placement) === alignment),
        ...allowedPlacements.filter((placement)=>getAlignment(placement) !== alignment)
    ] : allowedPlacements.filter((placement)=>getSide(placement) === placement);
    return allowedPlacementsSortedByAlignment.filter((placement)=>{
        if (alignment) {
            return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
        }
        return true;
    });
}
/**
 * Automatically chooses the `placement` which has the most space available.
 * @see https://floating-ui.com/docs/autoPlacement
 */ const autoPlacement = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'autoPlacement',
        options,
        async fn (middlewareArguments) {
            var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;
            const { x, y, rects, middlewareData, placement, platform, elements } = middlewareArguments;
            const { alignment = null, allowedPlacements = allPlacements, autoAlignment = true, ...detectOverflowOptions } = options;
            const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);
            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
            const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;
            const currentPlacement = placements[currentIndex];
            if (currentPlacement == null) {
                return {};
            }
            const { main, cross } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place
            if (placement !== currentPlacement) {
                return {
                    x,
                    y,
                    reset: {
                        placement: placements[0]
                    }
                };
            }
            const currentOverflows = [
                overflow[getSide(currentPlacement)],
                overflow[main],
                overflow[cross]
            ];
            const allOverflows = [
                ...(_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : [],
                {
                    placement: currentPlacement,
                    overflows: currentOverflows
                }
            ];
            const nextPlacement = placements[currentIndex + 1]; // There are more placements to check
            if (nextPlacement) {
                return {
                    data: {
                        index: currentIndex + 1,
                        overflows: allOverflows
                    },
                    reset: {
                        placement: nextPlacement
                    }
                };
            }
            const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b)=>a.overflows[0] - b.overflows[0]);
            const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref)=>{
                let { overflows } = _ref;
                return overflows.every((overflow)=>overflow <= 0);
            })) == null ? void 0 : _placementsSortedByLe.placement;
            const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;
            if (resetPlacement !== placement) {
                return {
                    data: {
                        index: currentIndex + 1,
                        overflows: allOverflows
                    },
                    reset: {
                        placement: resetPlacement
                    }
                };
            }
            return {};
        }
    };
};
function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [
        getOppositeAlignmentPlacement(placement),
        oppositePlacement,
        getOppositeAlignmentPlacement(oppositePlacement)
    ];
}
/**
 * Changes the placement of the floating element to one that will fit if the
 * initially specified `placement` does not.
 * @see https://floating-ui.com/docs/flip
 */ const flip = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'flip',
        options,
        async fn (middlewareArguments) {
            var _middlewareData$flip;
            const { placement, middlewareData, rects, initialPlacement, platform, elements } = middlewareArguments;
            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = 'bestFit', flipAlignment = true, ...detectOverflowOptions } = options;
            const side = getSide(placement);
            const isBasePlacement = side === initialPlacement;
            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [
                getOppositePlacement(initialPlacement)
            ] : getExpandedPlacements(initialPlacement));
            const placements = [
                initialPlacement,
                ...fallbackPlacements
            ];
            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
            const overflows = [];
            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
            if (checkMainAxis) {
                overflows.push(overflow[side]);
            }
            if (checkCrossAxis) {
                const { main, cross } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
                overflows.push(overflow[main], overflow[cross]);
            }
            overflowsData = [
                ...overflowsData,
                {
                    placement,
                    overflows
                }
            ]; // One or more sides is overflowing
            if (!overflows.every((side)=>side <= 0)) {
                var _middlewareData$flip$, _middlewareData$flip2;
                const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
                const nextPlacement = placements[nextIndex];
                if (nextPlacement) {
                    // Try next placement and re-run the lifecycle
                    return {
                        data: {
                            index: nextIndex,
                            overflows: overflowsData
                        },
                        reset: {
                            placement: nextPlacement
                        }
                    };
                }
                let resetPlacement = 'bottom';
                switch(fallbackStrategy){
                    case 'bestFit':
                        {
                            var _overflowsData$map$so;
                            const placement = (_overflowsData$map$so = overflowsData.map((d)=>[
                                    d,
                                    d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)
                                ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;
                            if (placement) {
                                resetPlacement = placement;
                            }
                            break;
                        }
                    case 'initialPlacement':
                        resetPlacement = initialPlacement;
                        break;
                }
                if (placement !== resetPlacement) {
                    return {
                        reset: {
                            placement: resetPlacement
                        }
                    };
                }
            }
            return {};
        }
    };
};
function getSideOffsets(overflow, rect) {
    return {
        top: overflow.top - rect.height,
        right: overflow.right - rect.width,
        bottom: overflow.bottom - rect.height,
        left: overflow.left - rect.width
    };
}
function isAnySideFullyClipped(overflow) {
    return sides.some((side)=>overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */ const hide = function(_temp) {
    let { strategy = 'referenceHidden', ...detectOverflowOptions } = _temp === void 0 ? {} : _temp;
    return {
        name: 'hide',
        async fn (middlewareArguments) {
            const { rects } = middlewareArguments;
            switch(strategy){
                case 'referenceHidden':
                    {
                        const overflow = await detectOverflow(middlewareArguments, {
                            ...detectOverflowOptions,
                            elementContext: 'reference'
                        });
                        const offsets = getSideOffsets(overflow, rects.reference);
                        return {
                            data: {
                                referenceHiddenOffsets: offsets,
                                referenceHidden: isAnySideFullyClipped(offsets)
                            }
                        };
                    }
                case 'escaped':
                    {
                        const overflow = await detectOverflow(middlewareArguments, {
                            ...detectOverflowOptions,
                            altBoundary: true
                        });
                        const offsets = getSideOffsets(overflow, rects.floating);
                        return {
                            data: {
                                escapedOffsets: offsets,
                                escaped: isAnySideFullyClipped(offsets)
                            }
                        };
                    }
                default:
                    {
                        return {};
                    }
            }
        }
    };
};
async function convertValueToCoords(middlewareArguments, value) {
    const { placement, platform, elements } = middlewareArguments;
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getMainAxisFromPlacement(placement) === 'x';
    const mainAxisMulti = [
        'left',
        'top'
    ].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const
    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === 'number' ? {
        mainAxis: rawValue,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: 0,
        crossAxis: 0,
        alignmentAxis: null,
        ...rawValue
    };
    if (alignment && typeof alignmentAxis === 'number') {
        crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti
    } : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti
    };
}
/**
 * Displaces the floating element from its reference element.
 * @see https://floating-ui.com/docs/offset
 */ const offset = function(value) {
    if (value === void 0) {
        value = 0;
    }
    return {
        name: 'offset',
        options: value,
        async fn (middlewareArguments) {
            const { x, y } = middlewareArguments;
            const diffCoords = await convertValueToCoords(middlewareArguments, value);
            return {
                x: x + diffCoords.x,
                y: y + diffCoords.y,
                data: diffCoords
            };
        }
    };
};
function getCrossAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
}
/**
 * Shifts the floating element in order to keep it in view when it will overflow
 * a clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */ const shift = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'shift',
        options,
        async fn (middlewareArguments) {
            const { x, y, placement } = middlewareArguments;
            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {
                fn: (_ref)=>{
                    let { x, y } = _ref;
                    return {
                        x,
                        y
                    };
                }
            }, ...detectOverflowOptions } = options;
            const coords = {
                x,
                y
            };
            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
            const mainAxis = getMainAxisFromPlacement(getSide(placement));
            const crossAxis = getCrossAxis(mainAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            if (checkMainAxis) {
                const minSide = mainAxis === 'y' ? 'top' : 'left';
                const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
                const min = mainAxisCoord + overflow[minSide];
                const max = mainAxisCoord - overflow[maxSide];
                mainAxisCoord = within(min, mainAxisCoord, max);
            }
            if (checkCrossAxis) {
                const minSide = crossAxis === 'y' ? 'top' : 'left';
                const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
                const min = crossAxisCoord + overflow[minSide];
                const max = crossAxisCoord - overflow[maxSide];
                crossAxisCoord = within(min, crossAxisCoord, max);
            }
            const limitedCoords = limiter.fn({
                ...middlewareArguments,
                [mainAxis]: mainAxisCoord,
                [crossAxis]: crossAxisCoord
            });
            return {
                ...limitedCoords,
                data: {
                    x: limitedCoords.x - x,
                    y: limitedCoords.y - y
                }
            };
        }
    };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */ const limitShift = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        options,
        fn (middlewareArguments) {
            const { x, y, placement, rects, middlewareData } = middlewareArguments;
            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = options;
            const coords = {
                x,
                y
            };
            const mainAxis = getMainAxisFromPlacement(placement);
            const crossAxis = getCrossAxis(mainAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            const rawOffset = typeof offset === 'function' ? offset({
                ...rects,
                placement
            }) : offset;
            const computedOffset = typeof rawOffset === 'number' ? {
                mainAxis: rawOffset,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...rawOffset
            };
            if (checkMainAxis) {
                const len = mainAxis === 'y' ? 'height' : 'width';
                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
                if (mainAxisCoord < limitMin) {
                    mainAxisCoord = limitMin;
                } else if (mainAxisCoord > limitMax) {
                    mainAxisCoord = limitMax;
                }
            }
            if (checkCrossAxis) {
                var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;
                const len = mainAxis === 'y' ? 'width' : 'height';
                const isOriginSide = [
                    'top',
                    'left'
                ].includes(getSide(placement));
                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);
                if (crossAxisCoord < limitMin) {
                    crossAxisCoord = limitMin;
                } else if (crossAxisCoord > limitMax) {
                    crossAxisCoord = limitMax;
                }
            }
            return {
                [mainAxis]: mainAxisCoord,
                [crossAxis]: crossAxisCoord
            };
        }
    };
};
/**
 * Provides data to change the size of the floating element. For instance,
 * prevent it from overflowing its clipping boundary or match the width of the
 * reference element.
 * @see https://floating-ui.com/docs/size
 */ const size = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'size',
        options,
        async fn (middlewareArguments) {
            const { placement, rects, platform, elements } = middlewareArguments;
            const { apply, ...detectOverflowOptions } = options;
            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
            const side = getSide(placement);
            const alignment = getAlignment(placement);
            let heightSide;
            let widthSide;
            if (side === 'top' || side === 'bottom') {
                heightSide = side;
                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? 'start' : 'end') ? 'left' : 'right';
            } else {
                widthSide = side;
                heightSide = alignment === 'end' ? 'top' : 'bottom';
            }
            const xMin = max(overflow.left, 0);
            const xMax = max(overflow.right, 0);
            const yMin = max(overflow.top, 0);
            const yMax = max(overflow.bottom, 0);
            const dimensions = {
                availableHeight: rects.floating.height - ([
                    'left',
                    'right'
                ].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),
                availableWidth: rects.floating.width - ([
                    'top',
                    'bottom'
                ].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])
            };
            const prevDimensions = await platform.getDimensions(elements.floating);
            apply == null ? void 0 : apply({
                ...middlewareArguments,
                ...dimensions
            });
            const nextDimensions = await platform.getDimensions(elements.floating);
            if (prevDimensions.width !== nextDimensions.width || prevDimensions.height !== nextDimensions.height) {
                return {
                    reset: {
                        rects: true
                    }
                };
            }
            return {};
        }
    };
};
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */ const inline = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'inline',
        options,
        async fn (middlewareArguments) {
            var _await$platform$getCl;
            const { placement, elements, rects, platform, strategy } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
            // ClientRect's bounds, despite the event listener being triggered. A
            // padding of 2 seems to handle this issue.
            const { padding = 2, x, y } = options;
            const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
                rect: rects.reference,
                offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),
                strategy
            }) : rects.reference);
            const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];
            const paddingObject = getSideObjectFromPadding(padding);
            function getBoundingClientRect() {
                // There are two rects and they are disjoined
                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
                    var _clientRects$find;
                    // Find the first rect in which the point is fully inside
                    return (_clientRects$find = clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;
                } // There are 2 or more connected rects
                if (clientRects.length >= 2) {
                    if (getMainAxisFromPlacement(placement) === 'x') {
                        const firstRect = clientRects[0];
                        const lastRect = clientRects[clientRects.length - 1];
                        const isTop = getSide(placement) === 'top';
                        const top = firstRect.top;
                        const bottom = lastRect.bottom;
                        const left = isTop ? firstRect.left : lastRect.left;
                        const right = isTop ? firstRect.right : lastRect.right;
                        const width = right - left;
                        const height = bottom - top;
                        return {
                            top,
                            bottom,
                            left,
                            right,
                            width,
                            height,
                            x: left,
                            y: top
                        };
                    }
                    const isLeftSide = getSide(placement) === 'left';
                    const maxRight = max(...clientRects.map((rect)=>rect.right));
                    const minLeft = min(...clientRects.map((rect)=>rect.left));
                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);
                    const top = measureRects[0].top;
                    const bottom = measureRects[measureRects.length - 1].bottom;
                    const left = minLeft;
                    const right = maxRight;
                    const width = right - left;
                    const height = bottom - top;
                    return {
                        top,
                        bottom,
                        left,
                        right,
                        width,
                        height,
                        x: left,
                        y: top
                    };
                }
                return fallback;
            }
            const resetRects = await platform.getElementRects({
                reference: {
                    getBoundingClientRect
                },
                floating: elements.floating,
                strategy
            });
            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
                return {
                    reset: {
                        rects: resetRects
                    }
                };
            }
            return {};
        }
    };
};
;
}}),
"[project]/node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "autoUpdate": (()=>autoUpdate),
    "computePosition": (()=>computePosition),
    "getOverflowAncestors": (()=>getOverflowAncestors)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$browser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs [app-client] (ecmascript)");
;
;
function isWindow(value) {
    return value && value.document && value.location && value.alert && value.setInterval;
}
function getWindow(node) {
    if (node == null) {
        return window;
    }
    if (!isWindow(node)) {
        const ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
}
function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
    return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';
}
function getUAString() {
    const uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands) {
        return uaData.brands.map((item)=>item.brand + "/" + item.version).join(' ');
    }
    return navigator.userAgent;
}
function isHTMLElement(value) {
    return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
    return value instanceof getWindow(value).Element;
}
function isNode(value) {
    return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
    // Browsers without `ShadowRoot` support
    if (typeof ShadowRoot === 'undefined') {
        return false;
    }
    const OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    const { overflow, overflowX, overflowY } = getComputedStyle$1(element);
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
    return [
        'table',
        'td',
        'th'
    ].includes(getNodeName(element));
}
function isContainingBlock(element) {
    // TODO: Try and use feature detection here instead
    const isFirefox = /firefox/i.test(getUAString());
    const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)
    css.contain === 'paint' || [
        'transform',
        'perspective'
    ].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);
}
function isLayoutViewport() {
    // Not Safari
    return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways
// • Always-visible scrollbar or not
// • Width of <html>, etc.
// const vV = win.visualViewport;
// return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;
    if (includeScale === void 0) {
        includeScale = false;
    }
    if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    let scaleX = 1;
    let scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    const win = isElement(element) ? getWindow(element) : window;
    const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
    const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
    const width = clientRect.width / scaleX;
    const height = clientRect.height / scaleY;
    return {
        width,
        height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x,
        y
    };
}
function getDocumentElement(node) {
    return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
    if (isElement(element)) {
        return {
            scrollLeft: element.scrollLeft,
            scrollTop: element.scrollTop
        };
    }
    return {
        scrollLeft: element.pageXOffset,
        scrollTop: element.pageYOffset
    };
}
function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
    const rect = getBoundingClientRect(element);
    return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');
    let scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const offsets = {
        x: 0,
        y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
        if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
            scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
            const offsetRect = getBoundingClientRect(offsetParent, true);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) {
            offsets.x = getWindowScrollBarX(documentElement);
        }
    }
    return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
    };
}
function getParentNode(node) {
    if (getNodeName(node) === 'html') {
        return node;
    }
    return(// @ts-ignore
    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    node.parentNode || (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected
    getDocumentElement(node) // fallback
    );
}
function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {
        return null;
    }
    return element.offsetParent;
}
function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
    }
    while(isHTMLElement(currentNode) && ![
        'html',
        'body'
    ].includes(getNodeName(currentNode))){
        if (isContainingBlock(currentNode)) {
            return currentNode;
        } else {
            currentNode = currentNode.parentNode;
        }
    }
    return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element) {
    const window1 = getWindow(element);
    let offsetParent = getTrueOffsetParent(element);
    while(offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static'){
        offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
        return window1;
    }
    return offsetParent || getContainingBlock(element) || window1;
}
function getDimensions(element) {
    if (isHTMLElement(element)) {
        return {
            width: element.offsetWidth,
            height: element.offsetHeight
        };
    }
    const rect = getBoundingClientRect(element);
    return {
        width: rect.width,
        height: rect.height
    };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let { rect, offsetParent, strategy } = _ref;
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    if (offsetParent === documentElement) {
        return rect;
    }
    let scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const offsets = {
        x: 0,
        y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
        if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
            scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
            const offsetRect = getBoundingClientRect(offsetParent, true);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        } // This doesn't appear to be need to be negated.
    // else if (documentElement) {
    //   offsets.x = getWindowScrollBarX(documentElement);
    // }
    }
    return {
        ...rect,
        x: rect.x - scroll.scrollLeft + offsets.x,
        y: rect.y - scroll.scrollTop + offsets.y
    };
}
function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        const layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === 'fixed') {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width,
        height,
        x,
        y
    };
}
// of the `<html>` and `<body>` rect bounds if horizontally scrollable
function getDocumentRect(element) {
    var _element$ownerDocumen;
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
        width,
        height,
        x,
        y
    };
}
function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if ([
        'html',
        'body',
        '#document'
    ].includes(getNodeName(parentNode))) {
        // @ts-ignore assume body is always available
        return node.ownerDocument.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
        return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
    var _node$ownerDocument;
    if (list === void 0) {
        list = [];
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
    const win = getWindow(scrollableAncestor);
    const target = isBody ? [
        win
    ].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
    const updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(getOverflowAncestors(target));
}
function contains(parent, child) {
    const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method
    if (parent.contains(child)) {
        return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
        let next = child;
        do {
            // use `===` replace node.isSameNode()
            if (next && parent === next) {
                return true;
            } // @ts-ignore: need a better way to handle this...
            next = next.parentNode || next.host;
        }while (next)
    }
    return false;
}
function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    return {
        top,
        left,
        x: left,
        y: top,
        right: left + element.clientWidth,
        bottom: top + element.clientHeight,
        width: element.clientWidth,
        height: element.clientHeight
    };
}
function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
    if (clippingParent === 'viewport') {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$browser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rectToClientRect"])(getViewportRect(element, strategy));
    }
    if (isElement(clippingParent)) {
        return getInnerBoundingClientRect(clippingParent, strategy);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$browser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rectToClientRect"])(getDocumentRect(getDocumentElement(element)));
} // A "clipping ancestor" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`
function getClippingAncestors(element) {
    const clippingAncestors = getOverflowAncestors(element);
    const canEscapeClipping = [
        'absolute',
        'fixed'
    ].includes(getComputedStyle$1(element).position);
    const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
        return [];
    } // @ts-ignore isElement check ensures we return Array<Element>
    return clippingAncestors.filter((clippingAncestors)=>isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');
} // Gets the maximum area that the element is visible in due to any number of
// clipping ancestors
function getClippingRect(_ref) {
    let { element, boundary, rootBoundary, strategy } = _ref;
    const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);
    const clippingAncestors = [
        ...mainClippingAncestors,
        rootBoundary
    ];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{
        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
        width: clippingRect.right - clippingRect.left,
        height: clippingRect.bottom - clippingRect.top,
        x: clippingRect.left,
        y: clippingRect.top
    };
}
const platform = {
    getClippingRect,
    convertOffsetParentRelativeRectToViewportRelativeRect,
    isElement,
    getDimensions,
    getOffsetParent,
    getDocumentElement,
    getElementRects: (_ref)=>{
        let { reference, floating, strategy } = _ref;
        return {
            reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
            floating: {
                ...getDimensions(floating),
                x: 0,
                y: 0
            }
        };
    },
    getClientRects: (element)=>Array.from(element.getClientRects()),
    isRTL: (element)=>getComputedStyle$1(element).direction === 'rtl'
};
/**
 * Automatically updates the position of the floating element when necessary.
 * @see https://floating-ui.com/docs/autoUpdate
 */ function autoUpdate(reference, floating, update, options) {
    if (options === void 0) {
        options = {};
    }
    const { ancestorScroll: _ancestorScroll = true, ancestorResize: _ancestorResize = true, elementResize = true, animationFrame = false } = options;
    const ancestorScroll = _ancestorScroll && !animationFrame;
    const ancestorResize = _ancestorResize && !animationFrame;
    const ancestors = ancestorScroll || ancestorResize ? [
        ...isElement(reference) ? getOverflowAncestors(reference) : [],
        ...getOverflowAncestors(floating)
    ] : [];
    ancestors.forEach((ancestor)=>{
        ancestorScroll && ancestor.addEventListener('scroll', update, {
            passive: true
        });
        ancestorResize && ancestor.addEventListener('resize', update);
    });
    let observer = null;
    if (elementResize) {
        let initialUpdate = true;
        observer = new ResizeObserver(()=>{
            if (!initialUpdate) {
                update();
            }
            initialUpdate = false;
        });
        isElement(reference) && !animationFrame && observer.observe(reference);
        observer.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
        frameLoop();
    }
    function frameLoop() {
        const nextRefRect = getBoundingClientRect(reference);
        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
            update();
        }
        prevRefRect = nextRefRect;
        frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return ()=>{
        var _observer;
        ancestors.forEach((ancestor)=>{
            ancestorScroll && ancestor.removeEventListener('scroll', update);
            ancestorResize && ancestor.removeEventListener('resize', update);
        });
        (_observer = observer) == null ? void 0 : _observer.disconnect();
        observer = null;
        if (animationFrame) {
            cancelAnimationFrame(frameId);
        }
    };
}
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */ const computePosition = (reference, floating, options)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$browser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computePosition"])(reference, floating, {
        platform,
        ...options
    });
;
}}),
"[project]/node_modules/no-scroll/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(root) {
    var isOn = false;
    var scrollbarSize;
    var scrollTop;
    function getScrollbarSize() {
        if (typeof scrollbarSize !== 'undefined') return scrollbarSize;
        var doc = document.documentElement;
        var dummyScroller = document.createElement('div');
        dummyScroller.setAttribute('style', 'width:99px;height:99px;' + 'position:absolute;top:-9999px;overflow:scroll;');
        doc.appendChild(dummyScroller);
        scrollbarSize = dummyScroller.offsetWidth - dummyScroller.clientWidth;
        doc.removeChild(dummyScroller);
        return scrollbarSize;
    }
    function hasScrollbar() {
        return document.documentElement.scrollHeight > window.innerHeight;
    }
    function on(options) {
        if (typeof document === 'undefined' || isOn) return;
        var doc = document.documentElement;
        scrollTop = window.pageYOffset;
        if (hasScrollbar()) {
            doc.style.width = 'calc(100% - ' + getScrollbarSize() + 'px)';
        } else {
            doc.style.width = '100%';
        }
        doc.style.position = 'fixed';
        doc.style.top = -scrollTop + 'px';
        doc.style.overflow = 'hidden';
        isOn = true;
    }
    function off() {
        if (typeof document === 'undefined' || !isOn) return;
        var doc = document.documentElement;
        doc.style.width = '';
        doc.style.position = '';
        doc.style.top = '';
        doc.style.overflow = '';
        window.scroll(0, scrollTop);
        isOn = false;
    }
    function toggle() {
        if (isOn) {
            off();
            return;
        }
        on();
    }
    var noScroll = {
        on: on,
        off: off,
        toggle: toggle
    };
    if (("TURBOPACK compile-time value", "object") !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = noScroll;
    } else {
        root.noScroll = noScroll;
    }
})(this);
}}),
"[project]/node_modules/tabbable/dist/index.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
/*!
* tabbable 5.3.3
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/ __turbopack_context__.s({
    "focusable": (()=>focusable),
    "isFocusable": (()=>isFocusable),
    "isTabbable": (()=>isTabbable),
    "tabbable": (()=>tabbable)
});
var candidateSelectors = [
    'input',
    'select',
    'textarea',
    'a[href]',
    'button',
    '[tabindex]:not(slot)',
    'audio[controls]',
    'video[controls]',
    '[contenteditable]:not([contenteditable="false"])',
    'details>summary:first-of-type',
    'details'
];
var candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');
var NoElement = typeof Element === 'undefined';
var matches = NoElement ? function() {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
    return element.getRootNode();
} : function(element) {
    return element.ownerDocument;
};
/**
 * @param {Element} el container to check in
 * @param {boolean} includeContainer add container to check
 * @param {(node: Element) => boolean} filter filter candidates
 * @returns {Element[]}
 */ var getCandidates = function getCandidates(el, includeContainer, filter) {
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
    if (includeContainer && matches.call(el, candidateSelector)) {
        candidates.unshift(el);
    }
    candidates = candidates.filter(filter);
    return candidates;
};
/**
 * @callback GetShadowRoot
 * @param {Element} element to check for shadow root
 * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.
 */ /**
 * @callback ShadowRootFilter
 * @param {Element} shadowHostNode the element which contains shadow content
 * @returns {boolean} true if a shadow root could potentially contain valid candidates.
 */ /**
 * @typedef {Object} CandidatesScope
 * @property {Element} scope contains inner candidates
 * @property {Element[]} candidates
 */ /**
 * @typedef {Object} IterativeOptions
 * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;
 *  if a function, implies shadow support is enabled and either returns the shadow root of an element
 *  or a boolean stating if it has an undisclosed shadow root
 * @property {(node: Element) => boolean} filter filter candidates
 * @property {boolean} flatten if true then result will flatten any CandidatesScope into the returned list
 * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;
 */ /**
 * @param {Element[]} elements list of element containers to match candidates from
 * @param {boolean} includeContainer add container list to check
 * @param {IterativeOptions} options
 * @returns {Array.<Element|CandidatesScope>}
 */ var getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
    var candidates = [];
    var elementsToCheck = Array.from(elements);
    while(elementsToCheck.length){
        var element = elementsToCheck.shift();
        if (element.tagName === 'SLOT') {
            // add shadow dom slot scope (slot itself cannot be focusable)
            var assigned = element.assignedElements();
            var content = assigned.length ? assigned : element.children;
            var nestedCandidates = getCandidatesIteratively(content, true, options);
            if (options.flatten) {
                candidates.push.apply(candidates, nestedCandidates);
            } else {
                candidates.push({
                    scope: element,
                    candidates: nestedCandidates
                });
            }
        } else {
            // check candidate element
            var validCandidate = matches.call(element, candidateSelector);
            if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
                candidates.push(element);
            } // iterate over shadow content if possible
            var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
            typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);
            var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
            if (shadowRoot && validShadowRoot) {
                // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed
                //  shadow exists, so look at light dom children as fallback BUT create a scope for any
                //  child candidates found because they're likely slotted elements (elements that are
                //  children of the web component element (which has the shadow), in the light dom, but
                //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,
                //  _after_ we return from this recursive call
                var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);
                if (options.flatten) {
                    candidates.push.apply(candidates, _nestedCandidates);
                } else {
                    candidates.push({
                        scope: element,
                        candidates: _nestedCandidates
                    });
                }
            } else {
                // there's not shadow so just dig into the element's (light dom) children
                //  __without__ giving the element special scope treatment
                elementsToCheck.unshift.apply(elementsToCheck, element.children);
            }
        }
    }
    return candidates;
};
var getTabindex = function getTabindex(node, isScope) {
    if (node.tabIndex < 0) {
        // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
        // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
        // yet they are still part of the regular tab order; in FF, they get a default
        // `tabIndex` of 0; since Chrome still puts those elements in the regular tab
        // order, consider their tab index to be 0.
        // Also browsers do not return `tabIndex` correctly for contentEditable nodes;
        // so if they don't have a tabindex attribute specifically set, assume it's 0.
        //
        // isScope is positive for custom element with shadow root or slot that by default
        // have tabIndex -1, but need to be sorted by document order in order for their
        // content to be inserted in the correct position
        if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {
            return 0;
        }
    }
    return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput(node) {
    return node.tagName === 'INPUT';
};
var isHiddenInput = function isHiddenInput(node) {
    return isInput(node) && node.type === 'hidden';
};
var isDetailsWithSummary = function isDetailsWithSummary(node) {
    var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === 'SUMMARY';
    });
    return r;
};
var getCheckedRadio = function getCheckedRadio(nodes, form) {
    for(var i = 0; i < nodes.length; i++){
        if (nodes[i].checked && nodes[i].form === form) {
            return nodes[i];
        }
    }
};
var isTabbableRadio = function isTabbableRadio(node) {
    if (!node.name) {
        return true;
    }
    var radioScope = node.form || getRootNode(node);
    var queryRadios = function queryRadios(name) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
    };
    var radioSet;
    if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {
        radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
        try {
            radioSet = queryRadios(node.name);
        } catch (err) {
            // eslint-disable-next-line no-console
            console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);
            return false;
        }
    }
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
};
var isRadio = function isRadio(node) {
    return isInput(node) && node.type === 'radio';
};
var isNonTabbableRadio = function isNonTabbableRadio(node) {
    return isRadio(node) && !isTabbableRadio(node);
};
var isZeroArea = function isZeroArea(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
};
var isHidden = function isHidden(node, _ref) {
    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
    // NOTE: visibility will be `undefined` if node is detached from the document
    //  (see notes about this further down), which means we will consider it visible
    //  (this is legacy behavior from a very long way back)
    // NOTE: we check this regardless of `displayCheck="none"` because this is a
    //  _visibility_ check, not a _display_ check
    if (getComputedStyle(node).visibility === 'hidden') {
        return true;
    }
    var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
    } // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
    //  (but NOT _the_ document; see second 'If' comment below for more).
    // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
    //  is attached, and the one we need to check if it's in the document or not (because the
    //  shadow, and all nodes it contains, is never considered in the document since shadows
    //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
    //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
    //  visibility, including all the nodes it contains). The host could be any normal node,
    //  or a custom element (i.e. web component). Either way, that's the one that is considered
    //  part of the document, not the shadow root, nor any of its children (i.e. the node being
    //  tested).
    // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
    //  document (per the docs) and while it's a Document-type object, that document does not
    //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
    //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
    //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
    //  node is actually detached.
    var nodeRootHost = getRootNode(node).host;
    var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
    if (!displayCheck || displayCheck === 'full') {
        if (typeof getShadowRoot === 'function') {
            // figure out if we should consider the node to be in an undisclosed shadow and use the
            //  'non-zero-area' fallback
            var originalNode = node;
            while(node){
                var parentElement = node.parentElement;
                var rootNode = getRootNode(node);
                if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
                ) {
                    // node has an undisclosed shadow which means we can only treat it as a black box, so we
                    //  fall back to a non-zero-area test
                    return isZeroArea(node);
                } else if (node.assignedSlot) {
                    // iterate up slot
                    node = node.assignedSlot;
                } else if (!parentElement && rootNode !== node.ownerDocument) {
                    // cross shadow boundary
                    node = rootNode.host;
                } else {
                    // iterate up normal dom
                    node = parentElement;
                }
            }
            node = originalNode;
        } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.
        if (nodeIsAttached) {
            // this works wherever the node is: if there's at least one client rect, it's
            //  somehow displayed; it also covers the CSS 'display: contents' case where the
            //  node itself is hidden in place of its contents; and there's no need to search
            //  up the hierarchy either
            return !node.getClientRects().length;
        } // Else, the node isn't attached to the document, which means the `getClientRects()`
    //  API will __always__ return zero rects (this can happen, for example, if React
    //  is used to render nodes onto a detached tree, as confirmed in this thread:
    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
    //
    // It also means that even window.getComputedStyle(node).display will return `undefined`
    //  because styles are only computed for nodes that are in the document.
    //
    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
    //  somehow. Though it was never stated officially, anyone who has ever used tabbable
    //  APIs on nodes in detached containers has actually implicitly used tabbable in what
    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
    //  considering __everything__ to be visible because of the innability to determine styles.
    } else if (displayCheck === 'non-zero-area') {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
    } // visible, as far as we can tell, or per current `displayCheck` mode
    return false;
}; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
//  unless they are in the _first_ <legend> element of the top-most disabled
//  fieldset
var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>
        while(parentNode){
            if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
                // look for the first <legend> among the children of the disabled <fieldset>
                for(var i = 0; i < parentNode.children.length; i++){
                    var child = parentNode.children.item(i); // when the first <legend> (in document order) is found
                    if (child.tagName === 'LEGEND') {
                        // if its parent <fieldset> is not nested in another disabled <fieldset>,
                        // return whether `node` is a descendant of its first <legend>
                        return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
                    }
                } // the disabled <fieldset> containing `node` has no <legend>
                return true;
            }
            parentNode = parentNode.parentElement;
        }
    } // else, node's tabbable/focusable state should not be affected by a fieldset's
    //  enabled/disabled state
    return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
    }
    return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {
    if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
        return false;
    }
    return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {
    var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);
    if (isNaN(tabIndex) || tabIndex >= 0) {
        return true;
    } // If a custom element has an explicit negative tabindex,
    // browsers will not allow tab targeting said element's children.
    return false;
};
/**
 * @param {Array.<Element|CandidatesScope>} candidates
 * @returns Element[]
 */ var sortByOrder = function sortByOrder(candidates) {
    var regularTabbables = [];
    var orderedTabbables = [];
    candidates.forEach(function(item, i) {
        var isScope = !!item.scope;
        var element = isScope ? item.scope : item;
        var candidateTabindex = getTabindex(element, isScope);
        var elements = isScope ? sortByOrder(item.candidates) : element;
        if (candidateTabindex === 0) {
            isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
        } else {
            orderedTabbables.push({
                documentOrder: i,
                tabIndex: candidateTabindex,
                item: item,
                isScope: isScope,
                content: elements
            });
        }
    });
    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
        sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
        return acc;
    }, []).concat(regularTabbables);
};
var tabbable = function tabbable(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
        candidates = getCandidatesIteratively([
            el
        ], options.includeContainer, {
            filter: isNodeMatchingSelectorTabbable.bind(null, options),
            flatten: false,
            getShadowRoot: options.getShadowRoot,
            shadowRootFilter: isValidShadowRootTabbable
        });
    } else {
        candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
    }
    return sortByOrder(candidates);
};
var focusable = function focusable(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
        candidates = getCandidatesIteratively([
            el
        ], options.includeContainer, {
            filter: isNodeMatchingSelectorFocusable.bind(null, options),
            flatten: true,
            getShadowRoot: options.getShadowRoot
        });
    } else {
        candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
    }
    return candidates;
};
var isTabbable = function isTabbable(node, options) {
    options = options || {};
    if (!node) {
        throw new Error('No node provided');
    }
    if (matches.call(node, candidateSelector) === false) {
        return false;
    }
    return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* #__PURE__ */ candidateSelectors.concat('iframe').join(',');
var isFocusable = function isFocusable(node, options) {
    options = options || {};
    if (!node) {
        throw new Error('No node provided');
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
    }
    return isNodeMatchingSelectorFocusable(options, node);
};
;
 //# sourceMappingURL=index.esm.js.map
}}),
"[project]/node_modules/focus-trap/dist/focus-trap.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
/*!
* focus-trap 6.9.4
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/ __turbopack_context__.s({
    "createFocusTrap": (()=>createFocusTrap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tabbable/dist/index.esm.js [app-client] (ecmascript)");
;
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread2(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var activeFocusTraps = function() {
    var trapQueue = [];
    return {
        activateTrap: function activateTrap(trap) {
            if (trapQueue.length > 0) {
                var activeTrap = trapQueue[trapQueue.length - 1];
                if (activeTrap !== trap) {
                    activeTrap.pause();
                }
            }
            var trapIndex = trapQueue.indexOf(trap);
            if (trapIndex === -1) {
                trapQueue.push(trap);
            } else {
                // move this existing trap to the front of the queue
                trapQueue.splice(trapIndex, 1);
                trapQueue.push(trap);
            }
        },
        deactivateTrap: function deactivateTrap(trap) {
            var trapIndex = trapQueue.indexOf(trap);
            if (trapIndex !== -1) {
                trapQueue.splice(trapIndex, 1);
            }
            if (trapQueue.length > 0) {
                trapQueue[trapQueue.length - 1].unpause();
            }
        }
    };
}();
var isSelectableInput = function isSelectableInput(node) {
    return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
};
var isEscapeEvent = function isEscapeEvent(e) {
    return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
};
var isTabEvent = function isTabEvent(e) {
    return e.key === 'Tab' || e.keyCode === 9;
};
var delay = function delay(fn) {
    return setTimeout(fn, 0);
}; // Array.find/findIndex() are not supported on IE; this replicates enough
//  of Array.findIndex() for our needs
var findIndex = function findIndex(arr, fn) {
    var idx = -1;
    arr.every(function(value, i) {
        if (fn(value)) {
            idx = i;
            return false; // break
        }
        return true; // next
    });
    return idx;
};
/**
 * Get an option's value when it could be a plain value, or a handler that provides
 *  the value.
 * @param {*} value Option's value to check.
 * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.
 * @returns {*} The `value`, or the handler's returned value.
 */ var valueOrHandler = function valueOrHandler(value) {
    for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        params[_key - 1] = arguments[_key];
    }
    return typeof value === 'function' ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget(event) {
    // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the
    //  shadow host. However, event.target.composedPath() will be an array of
    //  nodes "clicked" from inner-most (the actual element inside the shadow) to
    //  outer-most (the host HTML document). If we have access to composedPath(),
    //  then use its first element; otherwise, fall back to event.target (and
    //  this only works for an _open_ shadow DOM; otherwise,
    //  composedPath()[0] === event.target always).
    return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;
};
var createFocusTrap = function createFocusTrap(elements, userOptions) {
    // SSR: a live trap shouldn't be created in this type of environment so this
    //  should be safe code to execute if the `document` option isn't specified
    var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
    var config = _objectSpread2({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true,
        delayInitialFocus: true
    }, userOptions);
    var state = {
        // containers given to createFocusTrap()
        // @type {Array<HTMLElement>}
        containers: [],
        // list of objects identifying tabbable nodes in `containers` in the trap
        // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
        //  is active, but the trap should never get to a state where there isn't at least one group
        //  with at least one tabbable node in it (that would lead to an error condition that would
        //  result in an error being thrown)
        // @type {Array<{
        //   container: HTMLElement,
        //   tabbableNodes: Array<HTMLElement>, // empty if none
        //   focusableNodes: Array<HTMLElement>, // empty if none
        //   firstTabbableNode: HTMLElement|null,
        //   lastTabbableNode: HTMLElement|null,
        //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
        // }>}
        containerGroups: [],
        // same order/length as `containers` list
        // references to objects in `containerGroups`, but only those that actually have
        //  tabbable nodes in them
        // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
        //  the same length
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false,
        // timer ID for when delayInitialFocus is true and initial focus in this trap
        //  has been delayed during activation
        delayInitialFocusTimer: undefined
    };
    var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later
    /**
   * Gets a configuration option value.
   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,
   *  value will be taken from this object. Otherwise, value will be taken from base configuration.
   * @param {string} optionName Name of the option whose value is sought.
   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`
   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.
   */ var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {
        return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];
    };
    /**
   * Finds the index of the container that contains the element.
   * @param {HTMLElement} element
   * @returns {number} Index of the container in either `state.containers` or
   *  `state.containerGroups` (the order/length of these lists are the same); -1
   *  if the element isn't found.
   */ var findContainerIndex = function findContainerIndex(element) {
        // NOTE: search `containerGroups` because it's possible a group contains no tabbable
        //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)
        //  and we still need to find the element in there
        return state.containerGroups.findIndex(function(_ref) {
            var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
            return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
            //  web components if the `tabbableOptions.getShadowRoot` option was used for
            //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
            //  look inside web components even if open)
            tabbableNodes.find(function(node) {
                return node === element;
            });
        });
    };
    /**
   * Gets the node for the given option, which is expected to be an option that
   *  can be either a DOM node, a string that is a selector to get a node, `false`
   *  (if a node is explicitly NOT given), or a function that returns any of these
   *  values.
   * @param {string} optionName
   * @returns {undefined | false | HTMLElement | SVGElement} Returns
   *  `undefined` if the option is not specified; `false` if the option
   *  resolved to `false` (node explicitly not given); otherwise, the resolved
   *  DOM node.
   * @throws {Error} If the option is set, not `false`, and is not, or does not
   *  resolve to a node.
   */ var getNodeForOption = function getNodeForOption(optionName) {
        var optionValue = config[optionName];
        if (typeof optionValue === 'function') {
            for(var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                params[_key2 - 1] = arguments[_key2];
            }
            optionValue = optionValue.apply(void 0, params);
        }
        if (optionValue === true) {
            optionValue = undefined; // use default value
        }
        if (!optionValue) {
            if (optionValue === undefined || optionValue === false) {
                return optionValue;
            } // else, empty string (invalid), null (invalid), 0 (invalid)
            throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
        }
        var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point
        if (typeof optionValue === 'string') {
            node = doc.querySelector(optionValue); // resolve to node, or null if fails
            if (!node) {
                throw new Error("`".concat(optionName, "` as selector refers to no known node"));
            }
        }
        return node;
    };
    var getInitialFocusNode = function getInitialFocusNode() {
        var node = getNodeForOption('initialFocus'); // false explicitly indicates we want no initialFocus at all
        if (node === false) {
            return false;
        }
        if (node === undefined) {
            // option not specified: use fallback options
            if (findContainerIndex(doc.activeElement) >= 0) {
                node = doc.activeElement;
            } else {
                var firstTabbableGroup = state.tabbableGroups[0];
                var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode; // NOTE: `fallbackFocus` option function cannot return `false` (not supported)
                node = firstTabbableNode || getNodeForOption('fallbackFocus');
            }
        }
        if (!node) {
            throw new Error('Your focus-trap needs to have at least one focusable element');
        }
        return node;
    };
    var updateTabbableNodes = function updateTabbableNodes() {
        state.containerGroups = state.containers.map(function(container) {
            var tabbableNodes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tabbable"])(container, config.tabbableOptions); // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes
            //  are a superset of tabbable nodes
            var focusableNodes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["focusable"])(container, config.tabbableOptions);
            return {
                container: container,
                tabbableNodes: tabbableNodes,
                focusableNodes: focusableNodes,
                firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
                lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
                /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */ nextTabbableNode: function nextTabbableNode(node) {
                    var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                    // NOTE: If tabindex is positive (in order to manipulate the tab order separate
                    //  from the DOM order), this __will not work__ because the list of focusableNodes,
                    //  while it contains tabbable nodes, does not sort its nodes in any order other
                    //  than DOM order, because it can't: Where would you place focusable (but not
                    //  tabbable) nodes in that order? They have no order, because they aren't tabbale...
                    // Support for positive tabindex is already broken and hard to manage (possibly
                    //  not supportable, TBD), so this isn't going to make things worse than they
                    //  already are, and at least makes things better for the majority of cases where
                    //  tabindex is either 0/unset or negative.
                    // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375
                    var nodeIdx = focusableNodes.findIndex(function(n) {
                        return n === node;
                    });
                    if (nodeIdx < 0) {
                        return undefined;
                    }
                    if (forward) {
                        return focusableNodes.slice(nodeIdx + 1).find(function(n) {
                            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTabbable"])(n, config.tabbableOptions);
                        });
                    }
                    return focusableNodes.slice(0, nodeIdx).reverse().find(function(n) {
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTabbable"])(n, config.tabbableOptions);
                    });
                }
            };
        });
        state.tabbableGroups = state.containerGroups.filter(function(group) {
            return group.tabbableNodes.length > 0;
        }); // throw if no groups have tabbable nodes and we don't have a fallback focus node either
        if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option
        ) {
            throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');
        }
    };
    var tryFocus = function tryFocus(node) {
        if (node === false) {
            return;
        }
        if (node === doc.activeElement) {
            return;
        }
        if (!node || !node.focus) {
            tryFocus(getInitialFocusNode());
            return;
        }
        node.focus({
            preventScroll: !!config.preventScroll
        });
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
            node.select();
        }
    };
    var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {
        var node = getNodeForOption('setReturnFocus', previousActiveElement);
        return node ? node : node === false ? false : previousActiveElement;
    }; // This needs to be done on mousedown and touchstart instead of click
    // so that it precedes the focus event.
    var checkPointerDown = function checkPointerDown(e) {
        var target = getActualTarget(e);
        if (findContainerIndex(target) >= 0) {
            // allow the click since it ocurred inside the trap
            return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e)) {
            // immediately deactivate the trap
            trap.deactivate({
                // if, on deactivation, we should return focus to the node originally-focused
                //  when the trap was activated (or the configured `setReturnFocus` node),
                //  then assume it's also OK to return focus to the outside node that was
                //  just clicked, causing deactivation, as long as that node is focusable;
                //  if it isn't focusable, then return focus to the original node focused
                //  on activation (or the configured `setReturnFocus` node)
                // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
                //  which will result in the outside click setting focus to the node
                //  that was clicked, whether it's focusable or not; by setting
                //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
                //  on activation (or the configured `setReturnFocus` node)
                returnFocus: config.returnFocusOnDeactivate && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFocusable"])(target, config.tabbableOptions)
            });
            return;
        } // This is needed for mobile devices.
        // (If we'll only let `click` events through,
        // then on mobile they will be blocked anyways if `touchstart` is blocked.)
        if (valueOrHandler(config.allowOutsideClick, e)) {
            // allow the click outside the trap to take place
            return;
        } // otherwise, prevent the click
        e.preventDefault();
    }; // In case focus escapes the trap for some strange reason, pull it back in.
    var checkFocusIn = function checkFocusIn(e) {
        var target = getActualTarget(e);
        var targetContained = findContainerIndex(target) >= 0; // In Firefox when you Tab out of an iframe the Document is briefly focused.
        if (targetContained || target instanceof Document) {
            if (targetContained) {
                state.mostRecentlyFocusedNode = target;
            }
        } else {
            // escaped! pull it back in to where it just left
            e.stopImmediatePropagation();
            tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
        }
    }; // Hijack Tab events on the first and last focusable nodes of the trap,
    // in order to prevent focus from escaping. If it escapes for even a
    // moment it can end up scrolling the page and causing confusion so we
    // kind of need to capture the action at the keydown phase.
    var checkTab = function checkTab(e) {
        var target = getActualTarget(e);
        updateTabbableNodes();
        var destinationNode = null;
        if (state.tabbableGroups.length > 0) {
            // make sure the target is actually contained in a group
            // NOTE: the target may also be the container itself if it's focusable
            //  with tabIndex='-1' and was given initial focus
            var containerIndex = findContainerIndex(target);
            var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;
            if (containerIndex < 0) {
                // target not found in any group: quite possible focus has escaped the trap,
                //  so bring it back in to...
                if (e.shiftKey) {
                    // ...the last node in the last group
                    destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
                } else {
                    // ...the first node in the first group
                    destinationNode = state.tabbableGroups[0].firstTabbableNode;
                }
            } else if (e.shiftKey) {
                // REVERSE
                // is the target the first tabbable node in a group?
                var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
                    var firstTabbableNode = _ref2.firstTabbableNode;
                    return target === firstTabbableNode;
                });
                if (startOfGroupIndex < 0 && (containerGroup.container === target || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFocusable"])(target, config.tabbableOptions) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTabbable"])(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
                    // an exception case where the target is either the container itself, or
                    //  a non-tabbable node that was given focus (i.e. tabindex is negative
                    //  and user clicked on it or node was programmatically given focus)
                    //  and is not followed by any other tabbable node, in which
                    //  case, we should handle shift+tab as if focus were on the container's
                    //  first tabbable node, and go to the last tabbable node of the LAST group
                    startOfGroupIndex = containerIndex;
                }
                if (startOfGroupIndex >= 0) {
                    // YES: then shift+tab should go to the last tabbable node in the
                    //  previous group (and wrap around to the last tabbable node of
                    //  the LAST group if it's the first tabbable node of the FIRST group)
                    var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
                    var destinationGroup = state.tabbableGroups[destinationGroupIndex];
                    destinationNode = destinationGroup.lastTabbableNode;
                }
            } else {
                // FORWARD
                // is the target the last tabbable node in a group?
                var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
                    var lastTabbableNode = _ref3.lastTabbableNode;
                    return target === lastTabbableNode;
                });
                if (lastOfGroupIndex < 0 && (containerGroup.container === target || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFocusable"])(target, config.tabbableOptions) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTabbable"])(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
                    // an exception case where the target is the container itself, or
                    //  a non-tabbable node that was given focus (i.e. tabindex is negative
                    //  and user clicked on it or node was programmatically given focus)
                    //  and is not followed by any other tabbable node, in which
                    //  case, we should handle tab as if focus were on the container's
                    //  last tabbable node, and go to the first tabbable node of the FIRST group
                    lastOfGroupIndex = containerIndex;
                }
                if (lastOfGroupIndex >= 0) {
                    // YES: then tab should go to the first tabbable node in the next
                    //  group (and wrap around to the first tabbable node of the FIRST
                    //  group if it's the last tabbable node of the LAST group)
                    var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
                    var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
                    destinationNode = _destinationGroup.firstTabbableNode;
                }
            }
        } else {
            // NOTE: the fallbackFocus option does not support returning false to opt-out
            destinationNode = getNodeForOption('fallbackFocus');
        }
        if (destinationNode) {
            e.preventDefault();
            tryFocus(destinationNode);
        } // else, let the browser take care of [shift+]tab and move the focus
    };
    var checkKey = function checkKey(e) {
        if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {
            e.preventDefault();
            trap.deactivate();
            return;
        }
        if (isTabEvent(e)) {
            checkTab(e);
            return;
        }
    };
    var checkClick = function checkClick(e) {
        var target = getActualTarget(e);
        if (findContainerIndex(target) >= 0) {
            return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e)) {
            return;
        }
        if (valueOrHandler(config.allowOutsideClick, e)) {
            return;
        }
        e.preventDefault();
        e.stopImmediatePropagation();
    }; //
    // EVENT LISTENERS
    //
    var addListeners = function addListeners() {
        if (!state.active) {
            return;
        } // There can be only one listening focus trap at a time
        activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event
        // that caused the focus trap activation.
        state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
            tryFocus(getInitialFocusNode());
        }) : tryFocus(getInitialFocusNode());
        doc.addEventListener('focusin', checkFocusIn, true);
        doc.addEventListener('mousedown', checkPointerDown, {
            capture: true,
            passive: false
        });
        doc.addEventListener('touchstart', checkPointerDown, {
            capture: true,
            passive: false
        });
        doc.addEventListener('click', checkClick, {
            capture: true,
            passive: false
        });
        doc.addEventListener('keydown', checkKey, {
            capture: true,
            passive: false
        });
        return trap;
    };
    var removeListeners = function removeListeners() {
        if (!state.active) {
            return;
        }
        doc.removeEventListener('focusin', checkFocusIn, true);
        doc.removeEventListener('mousedown', checkPointerDown, true);
        doc.removeEventListener('touchstart', checkPointerDown, true);
        doc.removeEventListener('click', checkClick, true);
        doc.removeEventListener('keydown', checkKey, true);
        return trap;
    }; //
    // TRAP DEFINITION
    //
    trap = {
        get active () {
            return state.active;
        },
        get paused () {
            return state.paused;
        },
        activate: function activate(activateOptions) {
            if (state.active) {
                return this;
            }
            var onActivate = getOption(activateOptions, 'onActivate');
            var onPostActivate = getOption(activateOptions, 'onPostActivate');
            var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');
            if (!checkCanFocusTrap) {
                updateTabbableNodes();
            }
            state.active = true;
            state.paused = false;
            state.nodeFocusedBeforeActivation = doc.activeElement;
            if (onActivate) {
                onActivate();
            }
            var finishActivation = function finishActivation() {
                if (checkCanFocusTrap) {
                    updateTabbableNodes();
                }
                addListeners();
                if (onPostActivate) {
                    onPostActivate();
                }
            };
            if (checkCanFocusTrap) {
                checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
                return this;
            }
            finishActivation();
            return this;
        },
        deactivate: function deactivate(deactivateOptions) {
            if (!state.active) {
                return this;
            }
            var options = _objectSpread2({
                onDeactivate: config.onDeactivate,
                onPostDeactivate: config.onPostDeactivate,
                checkCanReturnFocus: config.checkCanReturnFocus
            }, deactivateOptions);
            clearTimeout(state.delayInitialFocusTimer); // noop if undefined
            state.delayInitialFocusTimer = undefined;
            removeListeners();
            state.active = false;
            state.paused = false;
            activeFocusTraps.deactivateTrap(trap);
            var onDeactivate = getOption(options, 'onDeactivate');
            var onPostDeactivate = getOption(options, 'onPostDeactivate');
            var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');
            var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');
            if (onDeactivate) {
                onDeactivate();
            }
            var finishDeactivation = function finishDeactivation() {
                delay(function() {
                    if (returnFocus) {
                        tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
                    }
                    if (onPostDeactivate) {
                        onPostDeactivate();
                    }
                });
            };
            if (returnFocus && checkCanReturnFocus) {
                checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
                return this;
            }
            finishDeactivation();
            return this;
        },
        pause: function pause() {
            if (state.paused || !state.active) {
                return this;
            }
            state.paused = true;
            removeListeners();
            return this;
        },
        unpause: function unpause() {
            if (!state.paused || !state.active) {
                return this;
            }
            state.paused = false;
            updateTabbableNodes();
            addListeners();
            return this;
        },
        updateContainerElements: function updateContainerElements(containerElements) {
            var elementsAsArray = [].concat(containerElements).filter(Boolean);
            state.containers = elementsAsArray.map(function(element) {
                return typeof element === 'string' ? doc.querySelector(element) : element;
            });
            if (state.active) {
                updateTabbableNodes();
            }
            return this;
        }
    }; // initialize container elements
    trap.updateContainerElements(elements);
    return trap;
};
;
 //# sourceMappingURL=focus-trap.esm.js.map
}}),
"[project]/node_modules/subtag/subtag.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
!function(root, name, make) {
    if (("TURBOPACK compile-time value", "object") != 'undefined' && module.exports) module.exports = make();
    else root[name] = make();
}(this, 'subtag', function() {
    var empty = '';
    var pattern = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
    function match(tag) {
        return tag.match(pattern) || [];
    }
    function split(tag) {
        return match(tag).filter(function(v, i) {
            return v && i;
        });
    }
    function api(tag) {
        tag = match(tag);
        return {
            language: tag[1] || empty,
            extlang: tag[2] || empty,
            script: tag[3] || empty,
            region: tag[4] || empty
        };
    }
    function expose(target, key, value) {
        Object.defineProperty(target, key, {
            value: value,
            enumerable: true
        });
    }
    function part(position, pattern, type) {
        function method(tag) {
            return match(tag)[position] || empty;
        }
        expose(method, 'pattern', pattern);
        expose(api, type, method);
    }
    part(1, /^[a-zA-Z]{2,3}$/, 'language');
    part(2, /^[a-zA-Z]{3}$/, 'extlang');
    part(3, /^[a-zA-Z]{4}$/, 'script');
    part(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, 'region');
    expose(api, 'split', split);
    return api;
});
}}),
"[project]/node_modules/@mapbox/sphericalmercator/sphericalmercator.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
var SphericalMercator = function() {
    // Closures including constants and other precalculated values.
    var cache = {}, EPSLN = 1.0e-10, D2R = Math.PI / 180, R2D = 180 / Math.PI, // 900913 properties.
    A = 6378137.0, MAXEXTENT = 20037508.342789244;
    function isFloat(n) {
        return Number(n) === n && n % 1 !== 0;
    }
    // SphericalMercator constructor: precaches calculations
    // for fast tile lookups.
    function SphericalMercator(options) {
        options = options || {};
        this.size = options.size || 256;
        this.expansion = options.antimeridian === true ? 2 : 1;
        if (!cache[this.size]) {
            var size = this.size;
            var c = cache[this.size] = {};
            c.Bc = [];
            c.Cc = [];
            c.zc = [];
            c.Ac = [];
            for(var d = 0; d < 30; d++){
                c.Bc.push(size / 360);
                c.Cc.push(size / (2 * Math.PI));
                c.zc.push(size / 2);
                c.Ac.push(size);
                size *= 2;
            }
        }
        this.Bc = cache[this.size].Bc;
        this.Cc = cache[this.size].Cc;
        this.zc = cache[this.size].zc;
        this.Ac = cache[this.size].Ac;
    }
    ;
    // Convert lon lat to screen pixel value
    //
    // - `ll` {Array} `[lon, lat]` array of geographic coordinates.
    // - `zoom` {Number} zoom level.
    SphericalMercator.prototype.px = function(ll, zoom) {
        if (isFloat(zoom)) {
            var size = this.size * Math.pow(2, zoom);
            var d = size / 2;
            var bc = size / 360;
            var cc = size / (2 * Math.PI);
            var ac = size;
            var f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);
            var x = d + ll[0] * bc;
            var y = d + 0.5 * Math.log((1 + f) / (1 - f)) * -cc;
            x > ac * this.expansion && (x = ac * this.expansion);
            y > ac && (y = ac);
            //(x < 0) && (x = 0);
            //(y < 0) && (y = 0);
            return [
                x,
                y
            ];
        } else {
            var d = this.zc[zoom];
            var f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);
            var x = Math.round(d + ll[0] * this.Bc[zoom]);
            var y = Math.round(d + 0.5 * Math.log((1 + f) / (1 - f)) * -this.Cc[zoom]);
            x > this.Ac[zoom] * this.expansion && (x = this.Ac[zoom] * this.expansion);
            y > this.Ac[zoom] && (y = this.Ac[zoom]);
            //(x < 0) && (x = 0);
            //(y < 0) && (y = 0);
            return [
                x,
                y
            ];
        }
    };
    // Convert screen pixel value to lon lat
    //
    // - `px` {Array} `[x, y]` array of geographic coordinates.
    // - `zoom` {Number} zoom level.
    SphericalMercator.prototype.ll = function(px, zoom) {
        if (isFloat(zoom)) {
            var size = this.size * Math.pow(2, zoom);
            var bc = size / 360;
            var cc = size / (2 * Math.PI);
            var zc = size / 2;
            var g = (px[1] - zc) / -cc;
            var lon = (px[0] - zc) / bc;
            var lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);
            return [
                lon,
                lat
            ];
        } else {
            var g = (px[1] - this.zc[zoom]) / -this.Cc[zoom];
            var lon = (px[0] - this.zc[zoom]) / this.Bc[zoom];
            var lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);
            return [
                lon,
                lat
            ];
        }
    };
    // Convert tile xyz value to bbox of the form `[w, s, e, n]`
    //
    // - `x` {Number} x (longitude) number.
    // - `y` {Number} y (latitude) number.
    // - `zoom` {Number} zoom.
    // - `tms_style` {Boolean} whether to compute using tms-style.
    // - `srs` {String} projection for resulting bbox (WGS84|900913).
    // - `return` {Array} bbox array of values in form `[w, s, e, n]`.
    SphericalMercator.prototype.bbox = function(x, y, zoom, tms_style, srs) {
        // Convert xyz into bbox with srs WGS84
        if (tms_style) {
            y = Math.pow(2, zoom) - 1 - y;
        }
        // Use +y to make sure it's a number to avoid inadvertent concatenation.
        var ll = [
            x * this.size,
            (+y + 1) * this.size
        ]; // lower left
        // Use +x to make sure it's a number to avoid inadvertent concatenation.
        var ur = [
            (+x + 1) * this.size,
            y * this.size
        ]; // upper right
        var bbox = this.ll(ll, zoom).concat(this.ll(ur, zoom));
        // If web mercator requested reproject to 900913.
        if (srs === '900913') {
            return this.convert(bbox, '900913');
        } else {
            return bbox;
        }
    };
    // Convert bbox to xyx bounds
    //
    // - `bbox` {Number} bbox in the form `[w, s, e, n]`.
    // - `zoom` {Number} zoom.
    // - `tms_style` {Boolean} whether to compute using tms-style.
    // - `srs` {String} projection of input bbox (WGS84|900913).
    // - `@return` {Object} XYZ bounds containing minX, maxX, minY, maxY properties.
    SphericalMercator.prototype.xyz = function(bbox, zoom, tms_style, srs) {
        // If web mercator provided reproject to WGS84.
        if (srs === '900913') {
            bbox = this.convert(bbox, 'WGS84');
        }
        var ll = [
            bbox[0],
            bbox[1]
        ]; // lower left
        var ur = [
            bbox[2],
            bbox[3]
        ]; // upper right
        var px_ll = this.px(ll, zoom);
        var px_ur = this.px(ur, zoom);
        // Y = 0 for XYZ is the top hence minY uses px_ur[1].
        var x = [
            Math.floor(px_ll[0] / this.size),
            Math.floor((px_ur[0] - 1) / this.size)
        ];
        var y = [
            Math.floor(px_ur[1] / this.size),
            Math.floor((px_ll[1] - 1) / this.size)
        ];
        var bounds = {
            minX: Math.min.apply(Math, x) < 0 ? 0 : Math.min.apply(Math, x),
            minY: Math.min.apply(Math, y) < 0 ? 0 : Math.min.apply(Math, y),
            maxX: Math.max.apply(Math, x),
            maxY: Math.max.apply(Math, y)
        };
        if (tms_style) {
            var tms = {
                minY: Math.pow(2, zoom) - 1 - bounds.maxY,
                maxY: Math.pow(2, zoom) - 1 - bounds.minY
            };
            bounds.minY = tms.minY;
            bounds.maxY = tms.maxY;
        }
        return bounds;
    };
    // Convert projection of given bbox.
    //
    // - `bbox` {Number} bbox in the form `[w, s, e, n]`.
    // - `to` {String} projection of output bbox (WGS84|900913). Input bbox
    //   assumed to be the "other" projection.
    // - `@return` {Object} bbox with reprojected coordinates.
    SphericalMercator.prototype.convert = function(bbox, to) {
        if (to === '900913') {
            return this.forward(bbox.slice(0, 2)).concat(this.forward(bbox.slice(2, 4)));
        } else {
            return this.inverse(bbox.slice(0, 2)).concat(this.inverse(bbox.slice(2, 4)));
        }
    };
    // Convert lon/lat values to 900913 x/y.
    SphericalMercator.prototype.forward = function(ll) {
        var xy = [
            A * ll[0] * D2R,
            A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * ll[1] * D2R))
        ];
        // if xy value is beyond maxextent (e.g. poles), return maxextent.
        xy[0] > MAXEXTENT && (xy[0] = MAXEXTENT);
        xy[0] < -MAXEXTENT && (xy[0] = -MAXEXTENT);
        xy[1] > MAXEXTENT && (xy[1] = MAXEXTENT);
        xy[1] < -MAXEXTENT && (xy[1] = -MAXEXTENT);
        return xy;
    };
    // Convert 900913 x/y values to lon/lat.
    SphericalMercator.prototype.inverse = function(xy) {
        return [
            xy[0] * R2D / A,
            (Math.PI * 0.5 - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D
        ];
    };
    return SphericalMercator;
}();
if (("TURBOPACK compile-time value", "object") !== 'undefined' && typeof exports !== 'undefined') {
    module.exports = exports = SphericalMercator;
}
}}),
"[project]/node_modules/@mapbox/search-js-react/dist/index-esm.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AddressAutofill": (()=>AddressAutofill),
    "AddressMinimap": (()=>AddressMinimap),
    "Geocoder": (()=>Geocoder),
    "SearchBox": (()=>SearchBox),
    "useAddressAutofillCore": (()=>useAddressAutofillCore),
    "useConfirmAddress": (()=>useConfirmAddress),
    "useEvented": (()=>useEvented),
    "useGeocodingCore": (()=>useGeocodingCore),
    "useMapboxAutofill": (()=>useAddressAutofillCore),
    "useSearchBoxCore": (()=>useSearchBoxCore),
    "useSearchSession": (()=>useSearchSession)
});
// src/components/AddressAutofill.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$core$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mapbox/search-js-core/dist/index-esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$web$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mapbox/search-js-web/dist/index-esm.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __objRest = (source, exclude)=>{
    var target = {};
    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
;
;
;
var AddressAutofill = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef((props, refProp)=>{
    const { accessToken, options, theme, popoverOptions, confirmOnBrowserAutofill, browserAutofillEnabled, children, onChange, onSuggest, onSuggestError, onRetrieve, interceptSearch } = props;
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(refProp, {
        "AddressAutofill.useImperativeHandle": ()=>({
                focus: ({
                    "AddressAutofill.useImperativeHandle": ()=>{
                        if (ref.current) return ref.current.focus();
                        throw new Error("AddressAutofill is not mounted");
                    }
                })["AddressAutofill.useImperativeHandle"]
            })
    }["AddressAutofill.useImperativeHandle"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressAutofill.useEffect": ()=>{
            if (ref.current) ref.current.options = options;
        }
    }["AddressAutofill.useEffect"], [
        ref.current,
        options
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressAutofill.useEffect": ()=>{
            if (ref.current) ref.current.interceptSearch = interceptSearch;
        }
    }["AddressAutofill.useEffect"], [
        ref.current,
        options
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressAutofill.useEffect": ()=>{
            if (ref.current) ref.current.theme = theme;
        }
    }["AddressAutofill.useEffect"], [
        ref.current,
        theme
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressAutofill.useEffect": ()=>{
            if (ref.current) ref.current.popoverOptions = popoverOptions;
        }
    }["AddressAutofill.useEffect"], [
        ref.current,
        popoverOptions
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressAutofill.useEffect": ()=>{
            if (ref.current) ref.current.confirmOnBrowserAutofill = confirmOnBrowserAutofill;
        }
    }["AddressAutofill.useEffect"], [
        ref.current,
        confirmOnBrowserAutofill
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressAutofill.useEffect": ()=>{
            if (ref.current) ref.current.browserAutofillEnabled = browserAutofillEnabled;
        }
    }["AddressAutofill.useEffect"], [
        ref.current,
        browserAutofillEnabled
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressAutofill.useEffect": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onSuggest) return;
            const fn = {
                "AddressAutofill.useEffect.fn": (e)=>onSuggest(e.detail)
            }["AddressAutofill.useEffect.fn"];
            node.addEventListener("suggest", fn);
            return ({
                "AddressAutofill.useEffect": ()=>{
                    node.removeEventListener("suggest", fn);
                }
            })["AddressAutofill.useEffect"];
        }
    }["AddressAutofill.useEffect"], [
        ref.current,
        onSuggest
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressAutofill.useEffect": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onSuggestError) return;
            const fn = {
                "AddressAutofill.useEffect.fn": (e)=>onSuggestError(e.detail)
            }["AddressAutofill.useEffect.fn"];
            node.addEventListener("suggesterror", fn);
            return ({
                "AddressAutofill.useEffect": ()=>{
                    node.removeEventListener("suggesterror", fn);
                }
            })["AddressAutofill.useEffect"];
        }
    }["AddressAutofill.useEffect"], [
        ref.current,
        onSuggestError
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressAutofill.useEffect": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onRetrieve) return;
            const fn = {
                "AddressAutofill.useEffect.fn": (e)=>onRetrieve(e.detail)
            }["AddressAutofill.useEffect.fn"];
            node.addEventListener("retrieve", fn);
            return ({
                "AddressAutofill.useEffect": ()=>{
                    node.removeEventListener("retrieve", fn);
                }
            })["AddressAutofill.useEffect"];
        }
    }["AddressAutofill.useEffect"], [
        ref.current,
        onRetrieve
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressAutofill.useEffect": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onChange) return;
            const fn = {
                "AddressAutofill.useEffect.fn": (e)=>{
                    if (e.target !== e.currentTarget) return;
                    onChange(e.detail);
                }
            }["AddressAutofill.useEffect.fn"];
            node.addEventListener("input", fn);
            return ({
                "AddressAutofill.useEffect": ()=>{
                    node.removeEventListener("input", fn);
                }
            })["AddressAutofill.useEffect"];
        }
    }["AddressAutofill.useEffect"], [
        ref.current,
        onChange
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressAutofill.useEffect": ()=>{
            if (ref.current) ref.current.accessToken = accessToken;
        }
    }["AddressAutofill.useEffect"], [
        ref.current,
        accessToken
    ]);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("mapbox-address-autofill", {
        ref
    }, children);
});
;
var SearchBox = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef((props, refProp)=>{
    const { accessToken, options, theme, popoverOptions, placeholder, map, marker, mapboxgl, value, onChange, onSuggest, onSuggestError, onRetrieve, onClear, interceptSearch } = props;
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(refProp, {
        "SearchBox.useImperativeHandle2": ()=>({
                focus: ({
                    "SearchBox.useImperativeHandle2": ()=>{
                        if (ref.current) return ref.current.focus();
                        throw new Error("SearchBox is not mounted");
                    }
                })["SearchBox.useImperativeHandle2"],
                search: ({
                    "SearchBox.useImperativeHandle2": (text)=>{
                        if (ref.current) return ref.current.search(text);
                        throw new Error("SearchBox is not mounted");
                    }
                })["SearchBox.useImperativeHandle2"]
            })
    }["SearchBox.useImperativeHandle2"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            if (ref.current) ref.current.options = options || {};
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        options
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            if (ref.current) ref.current.interceptSearch = interceptSearch;
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        interceptSearch
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            if (ref.current) ref.current.theme = theme;
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        theme
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            if (ref.current) ref.current.popoverOptions = popoverOptions;
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        popoverOptions
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            if (ref.current) ref.current.placeholder = placeholder;
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        placeholder
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            if (ref.current) ref.current.value = value || "";
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        value
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            const node = ref.current;
            if (!node) return;
            node.bindMap(map);
            return ({
                "SearchBox.useEffect2": ()=>{
                    node.unbindMap();
                }
            })["SearchBox.useEffect2"];
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        map
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            if (ref.current) ref.current.marker = marker;
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        marker
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            if (ref.current) ref.current.mapboxgl = mapboxgl;
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        mapboxgl
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onSuggest) return;
            const fn = {
                "SearchBox.useEffect2.fn": (e)=>onSuggest(e.detail)
            }["SearchBox.useEffect2.fn"];
            node.addEventListener("suggest", fn);
            return ({
                "SearchBox.useEffect2": ()=>{
                    node.removeEventListener("suggest", fn);
                }
            })["SearchBox.useEffect2"];
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        onSuggest
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onSuggestError) return;
            const fn = {
                "SearchBox.useEffect2.fn": (e)=>onSuggestError(e.detail)
            }["SearchBox.useEffect2.fn"];
            node.addEventListener("suggesterror", fn);
            return ({
                "SearchBox.useEffect2": ()=>{
                    node.removeEventListener("suggesterror", fn);
                }
            })["SearchBox.useEffect2"];
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        onSuggestError
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onRetrieve) return;
            const fn = {
                "SearchBox.useEffect2.fn": (e)=>onRetrieve(e.detail)
            }["SearchBox.useEffect2.fn"];
            node.addEventListener("retrieve", fn);
            return ({
                "SearchBox.useEffect2": ()=>{
                    node.removeEventListener("retrieve", fn);
                }
            })["SearchBox.useEffect2"];
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        onRetrieve
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onChange) return;
            const fn = {
                "SearchBox.useEffect2.fn": (e)=>{
                    if (e.target !== e.currentTarget) return;
                    onChange(e.detail);
                }
            }["SearchBox.useEffect2.fn"];
            node.addEventListener("input", fn);
            return ({
                "SearchBox.useEffect2": ()=>{
                    node.removeEventListener("input", fn);
                }
            })["SearchBox.useEffect2"];
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        onChange
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onClear) return;
            const fn = {
                "SearchBox.useEffect2.fn": ()=>{
                    onClear();
                }
            }["SearchBox.useEffect2.fn"];
            node.addEventListener("clear", fn);
            return ({
                "SearchBox.useEffect2": ()=>{
                    node.removeEventListener("clear", fn);
                }
            })["SearchBox.useEffect2"];
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        onClear
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "SearchBox.useEffect2": ()=>{
            if (ref.current) ref.current.accessToken = accessToken;
        }
    }["SearchBox.useEffect2"], [
        ref.current,
        accessToken
    ]);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("mapbox-search-box", {
        ref
    });
});
;
var Geocoder = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef((props, refProp)=>{
    const { accessToken, options, theme, popoverOptions, placeholder, map, marker, mapboxgl, value, onChange, onSuggest, onSuggestError, onRetrieve, onClear, interceptSearch } = props;
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(refProp, {
        "Geocoder.useImperativeHandle3": ()=>({
                focus: ({
                    "Geocoder.useImperativeHandle3": ()=>{
                        if (ref.current) return ref.current.focus();
                        throw new Error("Geocoder is not mounted");
                    }
                })["Geocoder.useImperativeHandle3"],
                search: ({
                    "Geocoder.useImperativeHandle3": (text)=>{
                        if (ref.current) return ref.current.search(text);
                        throw new Error("Geocoder is not mounted");
                    }
                })["Geocoder.useImperativeHandle3"]
            })
    }["Geocoder.useImperativeHandle3"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            if (ref.current) ref.current.options = options || {};
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        options
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            if (ref.current) ref.current.interceptSearch = interceptSearch;
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        interceptSearch
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            if (ref.current) ref.current.theme = theme;
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        theme
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            if (ref.current) ref.current.popoverOptions = popoverOptions;
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        popoverOptions
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            if (ref.current) ref.current.placeholder = placeholder;
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        placeholder
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            if (ref.current) ref.current.value = value || "";
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        value
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            const node = ref.current;
            if (!node) return;
            node.bindMap(map);
            return ({
                "Geocoder.useEffect3": ()=>{
                    node.unbindMap();
                }
            })["Geocoder.useEffect3"];
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        map
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            if (ref.current) ref.current.marker = marker;
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        marker
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            if (ref.current) ref.current.mapboxgl = mapboxgl;
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        mapboxgl
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onSuggest) return;
            const fn = {
                "Geocoder.useEffect3.fn": (e)=>onSuggest(e.detail)
            }["Geocoder.useEffect3.fn"];
            node.addEventListener("suggest", fn);
            return ({
                "Geocoder.useEffect3": ()=>{
                    node.removeEventListener("suggest", fn);
                }
            })["Geocoder.useEffect3"];
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        onSuggest
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onSuggestError) return;
            const fn = {
                "Geocoder.useEffect3.fn": (e)=>onSuggestError(e.detail)
            }["Geocoder.useEffect3.fn"];
            node.addEventListener("suggesterror", fn);
            return ({
                "Geocoder.useEffect3": ()=>{
                    node.removeEventListener("suggesterror", fn);
                }
            })["Geocoder.useEffect3"];
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        onSuggestError
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onRetrieve) return;
            const fn = {
                "Geocoder.useEffect3.fn": (e)=>onRetrieve(e.detail)
            }["Geocoder.useEffect3.fn"];
            node.addEventListener("retrieve", fn);
            return ({
                "Geocoder.useEffect3": ()=>{
                    node.removeEventListener("retrieve", fn);
                }
            })["Geocoder.useEffect3"];
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        onRetrieve
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onChange) return;
            const fn = {
                "Geocoder.useEffect3.fn": (e)=>{
                    if (e.target !== e.currentTarget) return;
                    onChange(e.detail);
                }
            }["Geocoder.useEffect3.fn"];
            node.addEventListener("input", fn);
            return ({
                "Geocoder.useEffect3": ()=>{
                    node.removeEventListener("input", fn);
                }
            })["Geocoder.useEffect3"];
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        onChange
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            const node = ref.current;
            if (!node) return;
            if (!onClear) return;
            const fn = {
                "Geocoder.useEffect3.fn": ()=>{
                    onClear();
                }
            }["Geocoder.useEffect3.fn"];
            node.addEventListener("clear", fn);
            return ({
                "Geocoder.useEffect3": ()=>{
                    node.removeEventListener("clear", fn);
                }
            })["Geocoder.useEffect3"];
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        onClear
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "Geocoder.useEffect3": ()=>{
            if (ref.current) ref.current.accessToken = accessToken;
        }
    }["Geocoder.useEffect3"], [
        ref.current,
        accessToken
    ]);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("mapbox-geocoder", {
        ref
    });
});
;
function AddressMinimap(props) {
    const { canAdjustMarker = false, keepMarkerCentered = false, markerAnchor = "bottom", onSaveMarkerLocation, show = false, accessToken, feature = null, adjustBtnText, saveBtnText, cancelBtnText, satelliteToggle = false, theme, mapStyleMode = "default", defaultMapStyle = [
        "mapbox",
        "streets-v11"
    ], footer } = props;
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressMinimap.useEffect4": ()=>{
            if (!ref.current) return;
            if (show) {
                ref.current.show();
            } else {
                ref.current.hide();
            }
        }
    }["AddressMinimap.useEffect4"], [
        ref.current,
        show
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressMinimap.useEffect4": ()=>{
            if (ref.current) ref.current.theme = theme;
        }
    }["AddressMinimap.useEffect4"], [
        ref.current,
        theme
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressMinimap.useEffect4": ()=>{
            if (ref.current) ref.current.feature = show ? feature : null;
        }
    }["AddressMinimap.useEffect4"], [
        ref.current,
        feature,
        show
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressMinimap.useEffect4": ()=>{
            if (ref.current) ref.current.mapStyleMode = mapStyleMode;
        }
    }["AddressMinimap.useEffect4"], [
        ref.current,
        mapStyleMode
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressMinimap.useEffect4": ()=>{
            if (adjustBtnText === void 0) return;
            if (ref.current) ref.current.adjustBtnText = adjustBtnText;
        }
    }["AddressMinimap.useEffect4"], [
        ref.current,
        adjustBtnText
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressMinimap.useEffect4": ()=>{
            if (saveBtnText === void 0) return;
            if (ref.current) ref.current.saveBtnText = saveBtnText;
        }
    }["AddressMinimap.useEffect4"], [
        ref.current,
        saveBtnText
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressMinimap.useEffect4": ()=>{
            if (cancelBtnText === void 0) return;
            if (ref.current) ref.current.cancelBtnText = cancelBtnText;
        }
    }["AddressMinimap.useEffect4"], [
        ref.current,
        cancelBtnText
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressMinimap.useEffect4": ()=>{
            if (ref.current) ref.current.defaultMapStyle = defaultMapStyle;
        }
    }["AddressMinimap.useEffect4"], [
        ref.current,
        defaultMapStyle
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressMinimap.useEffect4": ()=>{
            if (footer === void 0) return;
            if (ref.current) ref.current.footer = footer;
        }
    }["AddressMinimap.useEffect4"], [
        ref.current,
        footer
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressMinimap.useEffect4": ()=>{
            if (ref.current) ref.current.accessToken = accessToken;
        }
    }["AddressMinimap.useEffect4"], [
        ref.current,
        accessToken
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "AddressMinimap.useEffect4": ()=>{
            if (ref.current) ref.current.onSaveMarkerLocation = onSaveMarkerLocation;
        }
    }["AddressMinimap.useEffect4"], [
        ref.current,
        onSaveMarkerLocation
    ]);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("mapbox-address-minimap", {
        ref,
        "can-adjust-marker": canAdjustMarker,
        "keep-marker-centered": keepMarkerCentered,
        "marker-anchor": markerAnchor,
        "satellite-toggle": satelliteToggle
    });
}
;
function useEvented(evented, eventName, cb) {
    const cbRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(cb);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useEvented.useEffect5": ()=>{
            cbRef.current = cb;
        }
    }["useEvented.useEffect5"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useEvented.useEffect5": ()=>{
            if (!evented) return;
            const fn = {
                "useEvented.useEffect5.fn": (object)=>cbRef.current(object)
            }["useEvented.useEffect5.fn"];
            evented.addEventListener(eventName, fn);
            return ({
                "useEvented.useEffect5": ()=>{
                    evented.removeEventListener(eventName, fn);
                }
            })["useEvented.useEffect5"];
        }
    }["useEvented.useEffect5"], [
        evented,
        eventName,
        cbRef
    ]);
}
;
;
var DEFAULTS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$core$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AddressAutofillCore"].defaults;
function useAddressAutofillCore(options) {
    const autofill = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useAddressAutofillCore.useMemo[autofill]": ()=>{
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$core$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AddressAutofillCore"]();
        }
    }["useAddressAutofillCore.useMemo[autofill]"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useAddressAutofillCore.useEffect6": ()=>{
            const _a = options, { accessToken } = _a, restOptions = __objRest(_a, [
                "accessToken"
            ]);
            autofill.accessToken = accessToken;
            autofill.defaults = __spreadValues(__spreadValues({}, DEFAULTS), restOptions);
        }
    }["useAddressAutofillCore.useEffect6"], [
        options
    ]);
    return autofill;
}
;
;
var DEFAULTS2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$core$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SearchBoxCore"].defaults;
function useSearchBoxCore(options) {
    const search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useSearchBoxCore.useMemo2[search]": ()=>{
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$core$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SearchBoxCore"]();
        }
    }["useSearchBoxCore.useMemo2[search]"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useSearchBoxCore.useEffect7": ()=>{
            const _a = options, { accessToken } = _a, restOptions = __objRest(_a, [
                "accessToken"
            ]);
            search.accessToken = accessToken;
            search.defaults = __spreadValues(__spreadValues({}, DEFAULTS2), restOptions);
        }
    }["useSearchBoxCore.useEffect7"], [
        options
    ]);
    return search;
}
;
;
function useGeocodingCore(options) {
    const search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useGeocodingCore.useMemo3[search]": ()=>{
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$core$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeocodingCore"]();
        }
    }["useGeocodingCore.useMemo3[search]"], []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useGeocodingCore.useEffect8": ()=>{
            const _a = options, { accessToken } = _a, restOptions = __objRest(_a, [
                "accessToken"
            ]);
            search.accessToken = accessToken;
            search.defaults = __spreadValues({}, restOptions);
        }
    }["useGeocodingCore.useEffect8"], [
        options
    ]);
    return search;
}
;
;
function useSearchSession(search) {
    const searchSession = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useSearchSession.useMemo4[searchSession]": ()=>{
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$core$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SearchSession"](search);
        }
    }["useSearchSession.useMemo4[searchSession]"], [
        search
    ]);
    if (search instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$core$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SearchBoxCore"]) {
        return searchSession;
    } else if (search instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$core$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeocodingCore"]) {
        return searchSession;
    } else {
        return searchSession;
    }
}
;
;
function useConfirmAddress(optionsArg = {}) {
    const formRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useConfirmAddress.useMemo5": ()=>{
            return {
                formRef,
                showConfirm: ({
                    "useConfirmAddress.useMemo5": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$web$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["confirmAddress"])(formRef.current, optionsArg)
                })["useConfirmAddress.useMemo5"]
            };
        }
    }["useConfirmAddress.useMemo5"], [
        formRef,
        optionsArg
    ]);
}
;
 //# sourceMappingURL=index-esm.js.map
}}),
"[project]/node_modules/@mapbox/search-js-react/dist/index-esm.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, d: __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$web$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mapbox/search-js-web/dist/index-esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$core$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@mapbox/search-js-core/dist/index-esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mapbox$2f$search$2d$js$2d$react$2f$dist$2f$index$2d$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@mapbox/search-js-react/dist/index-esm.js [app-client] (ecmascript) <locals>");
}}),
}]);

//# sourceMappingURL=node_modules_a276545f._.js.map